<!DOCTYPE html>
<html>
  <head>
    <title>Expressions &middot; Advanced R.</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="www/bootstrap.min.css" rel="stylesheet">
    <link href="www/highlight.css" rel="stylesheet">

    <link href='http://fonts.googleapis.com/css?family=Inconsolata:400,700'
      rel='stylesheet' type='text/css'>
  </head>

  <body>

    <div class="container">

      <div class="masthead">
        <ul class="nav nav-pills pull-right">
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">
              Table of contents<b class="caret"></b>
            </a>
            <ul class="dropdown-menu pull-right" role="menu">
              <li><a href="Introduction.html">Introduction</a></li>
<li class="dropdown-header">Foundations</li>
<li><a href="Data-structures.html">Data structures</a></li>
<li><a href="Subsetting.html">Subsetting</a></li>
<li><a href="Vocabulary.html">Vocabulary</a></li>
<li><a href="Style.html">Style</a></li>
<li><a href="Functions.html">Functions</a></li>
<li><a href="OO-essentials.html">OO field guide</a></li>
<li><a href="Environments.html">Environments</a></li>
<li><a href="Exceptions-Debugging.html">Exceptions and debugging</a></li>

<li class="dropdown-header">Functional programming</li>
<li><a href="Functional-programming.html">Functional programming</a></li>
<li><a href="Functionals.html">Functionals</a></li>
<li><a href="Function-operators.html">Function operators</a></li>

<li class="dropdown-header">Metaprogramming</li>
<li><a href="Computing-on-the-language.html">Non-standard evaluation</a></li>
<li><a href="Expressions.html">Expressions</a></li>
<li><a href="dsl.html">Domain specific languages</a></li>

<li class="dropdown-header">Performant code</li>
<li><a href="Performance.html">Performance</a></li>
<li><a href="Profiling.html">Profiling</a></li>
<li><a href="memory.html">Memory</a></li>
<li><a href="Rcpp.html">Rcpp</a></li>
<li><a href="C-interface.html">R's C interface</a></li>

            </ul>
          </li>
        </ul>

        <h3 class="muted"><a href="/">Advanced R</a> <small>by Hadley Wickham</small></h3>
        <hr>
      </div>

      <div class="row">
        <div class="col-xs-12 col-sm-3" id="nav">
        <div class="well">
          Want to learn from me in person? I'm next teaching in <a href="https://rstudio-chicago.eventbrite.com">Chicago, May 27-28</a>.
        </div>

        <div class="well">
          Want a physical copy of this material? <a href="http://amzn.com/1466586966?tag=devtools-20">Buy a book from amazon!</a>.
        </div>

        <h4>Contents</h4>
          <ul class="list-unstyled" id="toc"></ul>

          <hr>
          <p><a href="/contribute.html">How to contribute</a></p>

          <p><a class="btn btn-primary" href="https://github.com/hadley/adv-r/edit/master/Expressions.rmd">Edit this page</a></p>
        </div>

        <div id="content" class="col-xs-12 col-sm-8 pull-right">
          <h1 id="metaprogramming">Expressions</h1>
<p>In <a href="Computing-on-the-language.html#nse">non-standard evaluation</a>, you learned the basics of accessing and evaluating the expressions underlying computation in R. In this chapter, you’ll learn how to manipulate these expressions with code. You’re going to learn how to metaprogram: how to create programs with other programs!  </p>
<h5>Outline</h5>
<ul>
<li><p><a href="Expressions.html#structure-of-expressions">Structure of expressions</a> begins with a deep dive into the structure of expressions. You’ll learn about the four components of an expression: constants, names, calls, and pairlists.</p></li>
<li><p><a href="Expressions.html#names">Names</a> goes into further details about names.</p></li>
<li><p><a href="Expressions.html#calls">Calls</a> gives more details about calls.</p></li>
<li><p><a href="Expressions.html#capturing-call">Capturing the current call</a> takes a minor detour to discuss some common uses of calls in base R.</p></li>
<li><p><a href="Expressions.html#pairlists">Pairlists</a> completes the discussion of the four major components of an expression, and shows how you can create functions from their component pieces.</p></li>
<li><p><a href="Expressions.html#parsing-and-deparsing">Parsing and deparsing</a> discusses how to convert back and forth between expressions and text.</p></li>
<li><p><a href="Expressions.html#ast-funs">Walking the call tree with recursive functions</a> concludes the chapter, combining everything you’ve learned about writing functions that can compute on and modify arbitrary R code.</p></li>
</ul>
<h5>Prerequisites</h5>
<p>Throughout this chapter we’re going to use tools from the <code>pryr</code> package to help see what’s going on. If you don’t already have it, install it by running <code>install.packages(&quot;pryr&quot;)</code>.</p>
<h2 id="structure-of-expressions">Structure of expressions</h2>
<p>To compute on the language, we first need to understand the structure of the language. That will require some new vocabulary, some new tools, and some new ways of thinking about R code. The first thing you’ll need to understand is the distinction between an operation and a result: </p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">4</span>
y &lt;-<span class="st"> </span>x *<span class="st"> </span><span class="dv">10</span>
y
<span class="co">#&gt; [1] 40</span></code></pre>
<p>We want to distinguish the action of multiplying <code>x</code> by 10 and assigning that result to <code>y</code> from the actual result (40). As we’ve seen in the previous chapter, we can capture the action with <code>quote()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">z &lt;-<span class="st"> </span><span class="kw">quote</span>(y &lt;-<span class="st"> </span>x *<span class="st"> </span><span class="dv">10</span>)
z
<span class="co">#&gt; y &lt;- x * 10</span></code></pre>
<p><code>quote()</code> returns an <strong>expression</strong>: an object that represents an action that can be performed by R. (Unfortunately <code>expression()</code> does not return an expression in this sense. Instead, it returns something more like a list of expressions. See <a href="Expressions.html#parsing-and-deparsing">parsing and deparsing</a> for more details.) </p>
<p>An expression is also called an abstract syntax tree (AST) because it represents the hierarchical tree structure of the code. We’ll use <code>pryr::ast()</code> to see this more clearly:  </p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ast</span>(y &lt;-<span class="st"> </span>x *<span class="st"> </span><span class="dv">10</span>)
<span class="co">#&gt; \- ()</span>
<span class="co">#&gt;   \- `&lt;-</span>
<span class="co">#&gt;   \- `y</span>
<span class="co">#&gt;   \- ()</span>
<span class="co">#&gt;     \- `*</span>
<span class="co">#&gt;     \- `x</span>
<span class="co">#&gt;     \-  10</span></code></pre>
<p>There are four possible components of an expression: constants, names, calls, and pairlists.</p>
<ul>
<li><p><strong>constants</strong> are length one atomic vectors, like <code>&quot;a&quot;</code> or <code>10</code>. <code>ast()</code> displays them as is. </p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ast</span>(<span class="st">&quot;a&quot;</span>)
<span class="co">#&gt; \-  &quot;a&quot;</span>
<span class="kw">ast</span>(<span class="dv">1</span>)
<span class="co">#&gt; \-  1</span>
<span class="kw">ast</span>(1L)
<span class="co">#&gt; \-  1L</span>
<span class="kw">ast</span>(<span class="ot">TRUE</span>)
<span class="co">#&gt; \-  TRUE</span></code></pre>
<p>Quoting a constant returns it unchanged:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">identical</span>(<span class="dv">1</span>, <span class="kw">quote</span>(<span class="dv">1</span>))
<span class="co">#&gt; [1] TRUE</span>
<span class="kw">identical</span>(<span class="st">&quot;test&quot;</span>, <span class="kw">quote</span>(<span class="st">&quot;test&quot;</span>))
<span class="co">#&gt; [1] TRUE</span></code></pre></li>
<li><p><strong>names</strong>, or symbols, represent the name of an object rather than its value. <code>ast()</code> prefixes names with a backtick.  </p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ast</span>(x)
<span class="co">#&gt; \- `x</span>
<span class="kw">ast</span>(mean)
<span class="co">#&gt; \- `mean</span>
<span class="kw">ast</span>(<span class="st">`</span><span class="dt">an unusual name</span><span class="st">`</span>)
<span class="co">#&gt; \- `an unusual name</span></code></pre></li>
<li><p><strong>calls</strong> represent the action of calling a function. Like lists, calls are recursive: they can contain constants, names, pairlists, and other calls. <code>ast()</code> prints <code>()</code> and then lists the children. The first child is the function that is called, and the remaining children are the function’s arguments. </p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ast</span>(<span class="kw">f</span>())
<span class="co">#&gt; \- ()</span>
<span class="co">#&gt;   \- `f</span>
<span class="kw">ast</span>(<span class="kw">f</span>(<span class="dv">1</span>, <span class="dv">2</span>))
<span class="co">#&gt; \- ()</span>
<span class="co">#&gt;   \- `f</span>
<span class="co">#&gt;   \-  1</span>
<span class="co">#&gt;   \-  2</span>
<span class="kw">ast</span>(<span class="kw">f</span>(a, b))
<span class="co">#&gt; \- ()</span>
<span class="co">#&gt;   \- `f</span>
<span class="co">#&gt;   \- `a</span>
<span class="co">#&gt;   \- `b</span>
<span class="kw">ast</span>(<span class="kw">f</span>(<span class="kw">g</span>(), <span class="kw">h</span>(<span class="dv">1</span>, a)))
<span class="co">#&gt; \- ()</span>
<span class="co">#&gt;   \- `f</span>
<span class="co">#&gt;   \- ()</span>
<span class="co">#&gt;     \- `g</span>
<span class="co">#&gt;   \- ()</span>
<span class="co">#&gt;     \- `h</span>
<span class="co">#&gt;     \-  1</span>
<span class="co">#&gt;     \- `a</span></code></pre>
<p>As mentioned in <a href="Functions.html#all-calls">every operation is a function call</a>, even things that don’t look like function calls still have this hierarchical structure:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ast</span>(a +<span class="st"> </span>b)
<span class="co">#&gt; \- ()</span>
<span class="co">#&gt;   \- `+</span>
<span class="co">#&gt;   \- `a</span>
<span class="co">#&gt;   \- `b</span>
<span class="kw">ast</span>(if (x &gt;<span class="st"> </span><span class="dv">1</span>) x else <span class="dv">1</span>/x)
<span class="co">#&gt; \- ()</span>
<span class="co">#&gt;   \- `if</span>
<span class="co">#&gt;   \- ()</span>
<span class="co">#&gt;     \- `&gt;</span>
<span class="co">#&gt;     \- `x</span>
<span class="co">#&gt;     \-  1</span>
<span class="co">#&gt;   \- `x</span>
<span class="co">#&gt;   \- ()</span>
<span class="co">#&gt;     \- `/</span>
<span class="co">#&gt;     \-  1</span>
<span class="co">#&gt;     \- `x</span></code></pre></li>
<li><p><strong>pairlists</strong>, short for dotted pair lists, are a legacy of R’s past. They are only used in one place: the formal arguments of a function. <code>ast()</code> prints <code>[]</code> at the top-level of a pairlist. Like calls, pairlists are also recursive and can contain constants, names, and calls. </p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ast</span>(function(<span class="dt">x =</span> <span class="dv">1</span>, y) x)
<span class="co">#&gt; \- ()</span>
<span class="co">#&gt;   \- `function</span>
<span class="co">#&gt;   \- []</span>
<span class="co">#&gt;     \ x = 1</span>
<span class="co">#&gt;     \ y =`MISSING</span>
<span class="co">#&gt;   \- `x</span>
<span class="co">#&gt;   \- &lt;srcref&gt;</span>
<span class="kw">ast</span>(function(<span class="dt">x =</span> <span class="dv">1</span>, <span class="dt">y =</span> x *<span class="st"> </span><span class="dv">2</span>) {x /<span class="st"> </span>y})
<span class="co">#&gt; \- ()</span>
<span class="co">#&gt;   \- `function</span>
<span class="co">#&gt;   \- []</span>
<span class="co">#&gt;     \ x = 1</span>
<span class="co">#&gt;     \ y =()</span>
<span class="co">#&gt;       \- `*</span>
<span class="co">#&gt;       \- `x</span>
<span class="co">#&gt;       \-  2</span>
<span class="co">#&gt;   \- ()</span>
<span class="co">#&gt;     \- `{</span>
<span class="co">#&gt;     \- ()</span>
<span class="co">#&gt;       \- `/</span>
<span class="co">#&gt;       \- `x</span>
<span class="co">#&gt;       \- `y</span>
<span class="co">#&gt;   \- &lt;srcref&gt;</span></code></pre></li>
</ul>
<p>Note that <code>str()</code> does not follow these naming conventions when describing objects. Instead, it describes names as symbols and calls as language objects:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(<span class="kw">quote</span>(a))
<span class="co">#&gt;  symbol a</span>
<span class="kw">str</span>(<span class="kw">quote</span>(a +<span class="st"> </span>b))
<span class="co">#&gt;  language a + b</span></code></pre>
<p>Using low-level functions, it is possible to create call trees that contain objects other than constants, names, calls, and pairlists. The following example uses <code>substitute()</code> to insert a data frame into a call tree. This is a bad idea, however, because the object does not print correctly: the printed call looks like it should return “list” but when evaluated, it returns “data.frame”. </p>
<pre class="sourceCode r"><code class="sourceCode r">class_df &lt;-<span class="st"> </span><span class="kw">substitute</span>(<span class="kw">class</span>(df), <span class="kw">list</span>(<span class="dt">df =</span> <span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">10</span>)))
class_df
<span class="co">#&gt; class(list(x = 10))</span>
<span class="kw">eval</span>(class_df)
<span class="co">#&gt; [1] &quot;data.frame&quot;</span></code></pre>
<p>Together these four components define the structure of all R code. They are explained in more detail in the following sections.</p>
<h3>Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>There’s no existing base function that checks if an element is a valid component of an expression (i.e., it’s a constant, name, call, or pairlist). Implement one by guessing the names of the “is” functions for calls, names, and pairlists.</p></li>
<li><p><code>pryr::ast()</code> uses non-standard evaluation. What’s its escape hatch to standard evaluation?</p></li>
<li><p>What does the call tree of an if statement with multiple else conditions look like?</p></li>
<li><p>Compare <code>ast(x + y %+% z)</code> to <code>ast(x ^ y %+% z)</code>. What do they tell you about the precedence of custom infix functions?</p></li>
<li><p>Why can’t an expression contain an atomic vector of length greater than one? Which one of the six types of atomic vector can’t appear in an expression? Why?</p></li>
</ol>
<h2 id="names">Names</h2>
<p>Typically, we use <code>quote()</code> to capture names. You can also convert a string to a name with <code>as.name()</code>. However, this is most useful only when your function receives strings as input. Otherwise it involves more typing than using <code>quote()</code>. (You can use <code>is.name()</code> to test if an object is a name.)  </p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">as.name</span>(<span class="st">&quot;name&quot;</span>)
<span class="co">#&gt; name</span>
<span class="kw">identical</span>(<span class="kw">quote</span>(name), <span class="kw">as.name</span>(<span class="st">&quot;name&quot;</span>))
<span class="co">#&gt; [1] TRUE</span>

<span class="kw">is.name</span>(<span class="st">&quot;name&quot;</span>)
<span class="co">#&gt; [1] FALSE</span>
<span class="kw">is.name</span>(<span class="kw">quote</span>(name))
<span class="co">#&gt; [1] TRUE</span>
<span class="kw">is.name</span>(<span class="kw">quote</span>(<span class="kw">f</span>(name)))
<span class="co">#&gt; [1] FALSE</span></code></pre>
<p>(Names are also called symbols. <code>as.symbol()</code> and <code>is.symbol()</code> are identical to <code>as.name()</code> and <code>is.name()</code>.)</p>
<p>Names that would otherwise be invalid are automatically surrounded by backticks: </p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">as.name</span>(<span class="st">&quot;a b&quot;</span>)
<span class="co">#&gt; `a b`</span>
<span class="kw">as.name</span>(<span class="st">&quot;if&quot;</span>)
<span class="co">#&gt; `if`</span></code></pre>
<p>There’s one special name that needs a little extra discussion: the empty name. It is used to represent missing arguments. This object behaves strangely. You can’t bind it to a variable. If you do, it triggers an error about missing arguments. It’s only useful if you want to programmatically create a function with missing arguments. </p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span>function(x) <span class="dv">10</span>
<span class="kw">formals</span>(f)$x
<span class="kw">is.name</span>(<span class="kw">formals</span>(f)$x)
<span class="co">#&gt; [1] TRUE</span>
<span class="kw">as.character</span>(<span class="kw">formals</span>(f)$x)
<span class="co">#&gt; [1] &quot;&quot;</span>

missing_arg &lt;-<span class="st"> </span><span class="kw">formals</span>(f)$x
<span class="co"># Doesn&#39;t work!</span>
<span class="kw">is.name</span>(missing_arg)
<span class="co">#&gt; Error in eval(expr, envir, enclos): argument &quot;missing_arg&quot; is missing, with no default</span></code></pre>
<p>To explicitly create it when needed, call <code>quote()</code> with a named argument:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">quote</span>(<span class="dt">expr =</span>)</code></pre>
<h3>Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>You can use <code>formals()</code> to both get and set the arguments of a function. Use <code>formals()</code> to modify the following function so that the default value of <code>x</code> is missing and <code>y</code> is 10.</p>
<pre class="sourceCode r"><code class="sourceCode r">g &lt;-<span class="st"> </span>function(<span class="dt">x =</span> <span class="dv">20</span>, y) {
  x +<span class="st"> </span>y
}</code></pre></li>
<li><p>Write an equivalent to <code>get()</code> using <code>as.name()</code> and <code>eval()</code>. Write an equivalent to <code>assign()</code> using <code>as.name()</code>, <code>substitute()</code>, and <code>eval()</code>. (Don’t worry about the multiple ways of choosing an environment; assume that the user supplies it explicitly.)</p></li>
</ol>
<h2 id="calls">Calls</h2>
<p>A call is very similar to a list. It has <code>length</code>, <code>[[</code> and <code>[</code> methods, and is recursive because calls can contain other calls. The first element of the call is the function that gets called. It’s usually the <em>name</em> of a function: </p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">quote</span>(<span class="kw">read.csv</span>(<span class="st">&quot;important.csv&quot;</span>, <span class="dt">row.names =</span> <span class="ot">FALSE</span>))
x[[<span class="dv">1</span>]]
<span class="co">#&gt; read.csv</span>
<span class="kw">is.name</span>(x[[<span class="dv">1</span>]])
<span class="co">#&gt; [1] TRUE</span></code></pre>
<p>But it can also be another call:</p>
<pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> </span><span class="kw">quote</span>(<span class="kw">add</span>(<span class="dv">10</span>)(<span class="dv">20</span>))
y[[<span class="dv">1</span>]]
<span class="co">#&gt; add(10)</span>
<span class="kw">is.call</span>(y[[<span class="dv">1</span>]])
<span class="co">#&gt; [1] TRUE</span></code></pre>
<p>The remaining elements are the arguments. They can be extracted by name or by position.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">quote</span>(<span class="kw">read.csv</span>(<span class="st">&quot;important.csv&quot;</span>, <span class="dt">row.names =</span> <span class="ot">FALSE</span>))
x[[<span class="dv">2</span>]]
<span class="co">#&gt; [1] &quot;important.csv&quot;</span>
x$row.names
<span class="co">#&gt; [1] FALSE</span>
<span class="kw">names</span>(x)
<span class="co">#&gt; [1] &quot;&quot;          &quot;&quot;          &quot;row.names&quot;</span></code></pre>
<p>The length of a call minus 1 gives the number of arguments:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">length</span>(x) -<span class="st"> </span><span class="dv">1</span>
<span class="co">#&gt; [1] 2</span></code></pre>
<h3>Modifying a call</h3>
<p>You can add, modify, and delete elements of the call with the standard replacement operators, <code>$&lt;-</code> and <code>[[&lt;-</code>: </p>
<pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> </span><span class="kw">quote</span>(<span class="kw">read.csv</span>(<span class="st">&quot;important.csv&quot;</span>, <span class="dt">row.names =</span> <span class="ot">FALSE</span>))
y$row.names &lt;-<span class="st"> </span><span class="ot">TRUE</span>
y$col.names &lt;-<span class="st"> </span><span class="ot">FALSE</span>
y
<span class="co">#&gt; read.csv(&quot;important.csv&quot;, row.names = TRUE, col.names = FALSE)</span>

y[[<span class="dv">2</span>]] &lt;-<span class="st"> </span><span class="kw">quote</span>(<span class="kw">paste0</span>(filename, <span class="st">&quot;.csv&quot;</span>))
y[[<span class="dv">4</span>]] &lt;-<span class="st"> </span><span class="ot">NULL</span>
y
<span class="co">#&gt; read.csv(paste0(filename, &quot;.csv&quot;), row.names = TRUE)</span>

y$sep &lt;-<span class="st"> &quot;,&quot;</span>
y
<span class="co">#&gt; read.csv(paste0(filename, &quot;.csv&quot;), row.names = TRUE, sep = &quot;,&quot;)</span></code></pre>
<p>Calls also support the <code>[</code> method. But use it with care. Removing the first element is unlikely to create a useful call.</p>
<pre class="sourceCode r"><code class="sourceCode r">x[-<span class="dv">3</span>] <span class="co"># remove the second argument</span>
<span class="co">#&gt; read.csv(&quot;important.csv&quot;)</span>
x[-<span class="dv">1</span>] <span class="co"># remove the function name - but it&#39;s still a call!</span>
<span class="co">#&gt; &quot;important.csv&quot;(row.names = FALSE)</span>
x
<span class="co">#&gt; read.csv(&quot;important.csv&quot;, row.names = FALSE)</span></code></pre>
<p>If you want a list of the unevaluated arguments (expressions), use explicit coercion:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># A list of the unevaluated arguments</span>
<span class="kw">as.list</span>(x[-<span class="dv">1</span>])
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; [1] &quot;important.csv&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $row.names</span>
<span class="co">#&gt; [1] FALSE</span></code></pre>
<p>Generally speaking, because R’s function calling semantics are so flexible, getting or setting arguments by position is dangerous. For example, even though the values at each position are different, the following three calls all have the same effect:</p>
<pre class="sourceCode r"><code class="sourceCode r">m1 &lt;-<span class="st"> </span><span class="kw">quote</span>(<span class="kw">read.delim</span>(<span class="st">&quot;data.txt&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;|&quot;</span>))
m2 &lt;-<span class="st"> </span><span class="kw">quote</span>(<span class="kw">read.delim</span>(<span class="dt">s =</span> <span class="st">&quot;|&quot;</span>, <span class="st">&quot;data.txt&quot;</span>))
m3 &lt;-<span class="st"> </span><span class="kw">quote</span>(<span class="kw">read.delim</span>(<span class="dt">file =</span> <span class="st">&quot;data.txt&quot;</span>, , <span class="st">&quot;|&quot;</span>))</code></pre>
<p>To work around this problem, pryr provides <code>standardise_call()</code>. It uses the base <code>match.call()</code> function to convert all positional arguments to named arguments:  </p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">standardise_call</span>(m1)
<span class="co">#&gt; read.delim(file = &quot;data.txt&quot;, sep = &quot;|&quot;)</span>
<span class="kw">standardise_call</span>(m2)
<span class="co">#&gt; read.delim(file = &quot;data.txt&quot;, sep = &quot;|&quot;)</span>
<span class="kw">standardise_call</span>(m3)
<span class="co">#&gt; read.delim(file = &quot;data.txt&quot;, sep = &quot;|&quot;)</span></code></pre>
<h3>Creating a call from its components</h3>
<p>To create a new call from its components, you can use <code>call()</code> or <code>as.call()</code>. The first argument to <code>call()</code> is a string which gives a function name. The other arguments are expressions that represent the arguments of the call.  </p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">call</span>(<span class="st">&quot;:&quot;</span>, <span class="dv">1</span>, <span class="dv">10</span>)
<span class="co">#&gt; 1:10</span>
<span class="kw">call</span>(<span class="st">&quot;mean&quot;</span>, <span class="kw">quote</span>(<span class="dv">1</span>:<span class="dv">10</span>), <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; mean(1:10, na.rm = TRUE)</span></code></pre>
<p><code>as.call()</code> is a minor variant of <code>call()</code> that takes a single list as input. The first element is a name or call. The subsequent elements are the arguments.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">as.call</span>(<span class="kw">list</span>(<span class="kw">quote</span>(mean), <span class="kw">quote</span>(<span class="dv">1</span>:<span class="dv">10</span>)))
<span class="co">#&gt; mean(1:10)</span>
<span class="kw">as.call</span>(<span class="kw">list</span>(<span class="kw">quote</span>(<span class="kw">adder</span>(<span class="dv">10</span>)), <span class="dv">20</span>))
<span class="co">#&gt; adder(10)(20)</span></code></pre>
<h3>Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>The following two calls look the same, but are actually different:</p>
<pre class="sourceCode r"><code class="sourceCode r">(a &lt;-<span class="st"> </span><span class="kw">call</span>(<span class="st">&quot;mean&quot;</span>, <span class="dv">1</span>:<span class="dv">10</span>))
<span class="co">#&gt; mean(1:10)</span>
(b &lt;-<span class="st"> </span><span class="kw">call</span>(<span class="st">&quot;mean&quot;</span>, <span class="kw">quote</span>(<span class="dv">1</span>:<span class="dv">10</span>)))
<span class="co">#&gt; mean(1:10)</span>
<span class="kw">identical</span>(a, b)
<span class="co">#&gt; [1] FALSE</span></code></pre>
<p>What’s the difference? Which one should you prefer?</p></li>
<li><p>Implement a pure R version of <code>do.call()</code>.</p></li>
<li><p>Concatenating a call and an expression with <code>c()</code> creates a list. Implement <code>concat()</code> so that the following code works to combine a call and an additional argument.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">concat</span>(<span class="kw">quote</span>(f), <span class="dt">a =</span> <span class="dv">1</span>, <span class="dt">b =</span> <span class="kw">quote</span>(<span class="kw">mean</span>(a)))
<span class="co">#&gt; f(a = 1, b = mean(a))</span></code></pre></li>
<li><p>Since <code>list()</code>s don’t belong in expressions, we could create a more convenient call constructor that automatically combines lists into the arguments. Implement <code>make_call()</code> so that the following code works.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">make_call</span>(<span class="kw">quote</span>(mean), <span class="kw">list</span>(<span class="kw">quote</span>(x), <span class="dt">na.rm =</span> <span class="ot">TRUE</span>))
<span class="co">#&gt; mean(x, na.rm = TRUE)</span>
<span class="kw">make_call</span>(<span class="kw">quote</span>(mean), <span class="kw">quote</span>(x), <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; mean(x, na.rm = TRUE)</span></code></pre></li>
<li><p>How does <code>mode&lt;-</code> work? How does it use <code>call()</code>?</p></li>
<li><p>Read the source for <code>pryr::standardise_call()</code>. How does it work? Why is <code>is.primitive()</code> needed?</p></li>
<li><p><code>standardise_call()</code> doesn’t work so well for the following calls. Why?</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">standardise_call</span>(<span class="kw">quote</span>(<span class="kw">mean</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)))
<span class="co">#&gt; mean(x = 1:10, na.rm = TRUE)</span>
<span class="kw">standardise_call</span>(<span class="kw">quote</span>(<span class="kw">mean</span>(<span class="dt">n =</span> T, <span class="dv">1</span>:<span class="dv">10</span>)))
<span class="co">#&gt; mean(x = 1:10, n = T)</span>
<span class="kw">standardise_call</span>(<span class="kw">quote</span>(<span class="kw">mean</span>(<span class="dt">x =</span> <span class="dv">1</span>:<span class="dv">10</span>, , <span class="ot">TRUE</span>)))
<span class="co">#&gt; mean(x = 1:10, , TRUE)</span></code></pre></li>
<li><p>Read the documentation for <code>pryr::modify_call()</code>. How do you think it works? Read the source code.</p></li>
<li><p>Use <code>ast()</code> and experimentation to figure out the three arguments in an <code>if()</code> call. Which components are required? What are the arguments to the <code>for()</code> and <code>while()</code> calls?</p></li>
</ol>
<h2 id="capturing-call">Capturing the current call</h2>
<p>Many base R functions use the current call: the expression that caused the current function to be run. There are two ways to capture a current call: </p>
<ul>
<li><p><code>sys.call()</code> captures exactly what the user typed. </p></li>
<li><p><code>match.call()</code> makes a call that only uses named arguments. It’s like automatically calling <code>pryr::standardise_call()</code> on the result of <code>sys.call()</code> </p></li>
</ul>
<p>The following example illustrates the difference between the two:</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span>function(<span class="dt">abc =</span> <span class="dv">1</span>, <span class="dt">def =</span> <span class="dv">2</span>, <span class="dt">ghi =</span> <span class="dv">3</span>) {
  <span class="kw">list</span>(<span class="dt">sys =</span> <span class="kw">sys.call</span>(), <span class="dt">match =</span> <span class="kw">match.call</span>())
}
<span class="kw">f</span>(<span class="dt">d =</span> <span class="dv">2</span>, <span class="dv">2</span>)
<span class="co">#&gt; $sys</span>
<span class="co">#&gt; f(d = 2, 2)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $match</span>
<span class="co">#&gt; f(abc = 2, def = 2)</span></code></pre>
<p>Modelling functions often use <code>match.call()</code> to capture the call used to create the model. This makes it possible to <code>update()</code> a model, re-fitting the model after modifying some of original arguments. Here’s an example of <code>update()</code> in action: </p>
<pre class="sourceCode r"><code class="sourceCode r">mod &lt;-<span class="st"> </span><span class="kw">lm</span>(mpg ~<span class="st"> </span>wt, <span class="dt">data =</span> mtcars)
<span class="kw">update</span>(mod, <span class="dt">formula =</span> . ~<span class="st"> </span>. +<span class="st"> </span>cyl)
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = mpg ~ wt + cyl, data = mtcars)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; (Intercept)           wt          cyl  </span>
<span class="co">#&gt;      39.686       -3.191       -1.508</span></code></pre>
<p>How does <code>update()</code> work? We can rewrite it using some tools from pryr to focus on the essence of the algorithm.</p>
<pre class="sourceCode r"><code class="sourceCode r">update_call &lt;-<span class="st"> </span>function (object, formula., ...) {
  call &lt;-<span class="st"> </span>object$call

  <span class="co"># Use update.formula to deal with formulas like . ~ .</span>
  if (!<span class="kw">missing</span>(formula.)) {
    call$formula &lt;-<span class="st"> </span><span class="kw">update.formula</span>(<span class="kw">formula</span>(object), formula.)
  }

  <span class="kw">modify_call</span>(call, <span class="kw">dots</span>(...))
}
update_model &lt;-<span class="st"> </span>function(object, formula., ...) {
  call &lt;-<span class="st"> </span><span class="kw">update_call</span>(object, formula., ...)
  <span class="kw">eval</span>(call, <span class="kw">parent.frame</span>())
}
<span class="kw">update_model</span>(mod, <span class="dt">formula =</span> . ~<span class="st"> </span>. +<span class="st"> </span>cyl)
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = mpg ~ wt + cyl, data = mtcars)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; (Intercept)           wt          cyl  </span>
<span class="co">#&gt;      39.686       -3.191       -1.508</span></code></pre>
<p>The original <code>update()</code> has an <code>evaluate</code> argument that controls whether the function returns the call or the result. But I think it’s better, on principle, that a function returns only one type of object, rather than different types depending on the function’s arguments.</p>
<p>This rewrite also allows us to fix a small bug in <code>update()</code>: it re-evaluates the call in the global environment, when what we really want is to re-evaluate it in the environment where the model was originally fit — in the formula.</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span>function() {
  n &lt;-<span class="st"> </span><span class="dv">3</span>
  <span class="kw">lm</span>(mpg ~<span class="st"> </span><span class="kw">poly</span>(wt, n), <span class="dt">data =</span> mtcars)
}
mod &lt;-<span class="st"> </span><span class="kw">f</span>()
<span class="kw">update</span>(mod, <span class="dt">data =</span> mtcars)
<span class="co">#&gt; Error in poly(wt, n): object &#39;n&#39; not found</span>

update_model &lt;-<span class="st"> </span>function(object, formula., ...) {
  call &lt;-<span class="st"> </span><span class="kw">update_call</span>(object, formula., ...)
  <span class="kw">eval</span>(call, <span class="kw">environment</span>(<span class="kw">formula</span>(object)))
}
<span class="kw">update_model</span>(mod, <span class="dt">data =</span> mtcars)
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = mpg ~ poly(wt, n), data = mtcars)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt;  (Intercept)  poly(wt, n)1  poly(wt, n)2  poly(wt, n)3  </span>
<span class="co">#&gt;      20.0906      -29.1157        8.6358        0.2749</span></code></pre>
<p>This is an important principle to remember: if you want to re-run code captured with <code>match.call()</code>, you also need to capture the environment in which it was evaluated, usually the <code>parent.frame()</code>. The downside to this is that capturing the environment also means capturing any large objects which happen to be in that environment, which prevents their memory from being released. This topic is explored in more detail in <a href="memory.html#gc">garbage collection</a>. </p>
<p>Some base R functions use <code>match.call()</code> where it’s not necessary. For example, <code>write.csv()</code> captures the call to <code>write.csv()</code> and mangles it to call <code>write.table()</code> instead:</p>
<pre class="sourceCode r"><code class="sourceCode r">write.csv &lt;-<span class="st"> </span>function(...) {
  Call &lt;-<span class="st"> </span><span class="kw">match.call</span>(<span class="dt">expand.dots =</span> <span class="ot">TRUE</span>)
  for (arg in <span class="kw">c</span>(<span class="st">&quot;append&quot;</span>, <span class="st">&quot;col.names&quot;</span>, <span class="st">&quot;sep&quot;</span>, <span class="st">&quot;dec&quot;</span>, <span class="st">&quot;qmethod&quot;</span>)) {
    if (!<span class="kw">is.null</span>(Call[[arg]])) {
      <span class="kw">warning</span>(<span class="kw">gettextf</span>(<span class="st">&quot;attempt to set &#39;%s&#39; ignored&quot;</span>, arg))
    }
  }
  rn &lt;-<span class="st"> </span><span class="kw">eval.parent</span>(Call$row.names)
  Call$append &lt;-<span class="st"> </span><span class="ot">NULL</span>
  Call$col.names &lt;-<span class="st"> </span>if (<span class="kw">is.logical</span>(rn) &amp;&amp;<span class="st"> </span>!rn) <span class="ot">TRUE</span> else <span class="ot">NA</span>
  Call$sep &lt;-<span class="st"> &quot;,&quot;</span>
  Call$dec &lt;-<span class="st"> &quot;.&quot;</span>
  Call$qmethod &lt;-<span class="st"> &quot;double&quot;</span>
  Call[[1L]] &lt;-<span class="st"> </span><span class="kw">as.name</span>(<span class="st">&quot;write.table&quot;</span>)
  <span class="kw">eval.parent</span>(Call)
}</code></pre>
<p>To fix this, we could implement <code>write.csv()</code> using regular function call semantics:</p>
<pre class="sourceCode r"><code class="sourceCode r">write.csv &lt;-<span class="st"> </span>function(x, <span class="dt">file =</span> <span class="st">&quot;&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;,&quot;</span>, <span class="dt">qmethod =</span> <span class="st">&quot;double&quot;</span>, 
                      ...) {
  <span class="kw">write.table</span>(<span class="dt">x =</span> x, <span class="dt">file =</span> file, <span class="dt">sep =</span> sep, <span class="dt">qmethod =</span> qmethod, 
    ...)
}</code></pre>
<p>This is much easier to understand: it’s just calling <code>write.table()</code> with different defaults. This also fixes a subtle bug in the original <code>write.csv()</code>: <code>write.csv(mtcars, row = FALSE)</code> raises an error, but <code>write.csv(mtcars, row.names = FALSE)</code> does not. The lesson here is that it’s always better to solve a problem with the simplest tool possible.</p>
<h3>Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Compare and contrast <code>update_model()</code> with <code>update.default()</code>.</p></li>
<li><p>Why doesn’t <code>write.csv(mtcars, &quot;mtcars.csv&quot;, row = FALSE)</code> work? What property of argument matching has the original author forgotten?</p></li>
<li><p>Rewrite <code>update.formula()</code> to use R code instead of C code.</p></li>
<li><p>Sometimes it’s necessary to uncover the function that called the function that called the current function (i.e., the grandparent, not the parent). How can you use <code>sys.call()</code> or <code>match.call()</code> to find this function?</p></li>
</ol>
<h2 id="pairlists">Pairlists</h2>
<p>Pairlists are a holdover from R’s past. They behave identically to lists, but have a different internal representation (as a linked list rather than a vector). Pairlists have been replaced by lists everywhere except in function arguments. </p>
<p>The only place you need to care about the difference between a list and a pairlist is if you’re going to construct functions by hand. For example, the following function allows you to construct a function from its component pieces: a list of formal arguments, a body, and an environment. The function uses <code>as.pairlist()</code> to ensure that the <code>function()</code> has the pairlist of <code>args</code> it needs.   </p>
<pre class="sourceCode r"><code class="sourceCode r">make_function &lt;-<span class="st"> </span>function(args, body, <span class="dt">env =</span> <span class="kw">parent.frame</span>()) {
  args &lt;-<span class="st"> </span><span class="kw">as.pairlist</span>(args)

  <span class="kw">eval</span>(<span class="kw">call</span>(<span class="st">&quot;function&quot;</span>, args, body), env)
}</code></pre>
<p>This function is also available in pryr, where it does a little extra checking of arguments. <code>make_function()</code> is best used in conjunction with <code>alist()</code>, the <strong>a</strong>rgument list function. <code>alist()</code> doesn’t evaluate its arguments so that <code>alist(x = a)</code> is shorthand for <code>list(x = quote(a))</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">add &lt;-<span class="st"> </span><span class="kw">make_function</span>(<span class="kw">alist</span>(<span class="dt">a =</span> <span class="dv">1</span>, <span class="dt">b =</span> <span class="dv">2</span>), <span class="kw">quote</span>(a +<span class="st"> </span>b))
<span class="kw">add</span>(<span class="dv">1</span>)
<span class="co">#&gt; [1] 3</span>
<span class="kw">add</span>(<span class="dv">1</span>, <span class="dv">2</span>)
<span class="co">#&gt; [1] 3</span>

<span class="co"># To have an argument with no default, you need an explicit =</span>
<span class="kw">make_function</span>(<span class="kw">alist</span>(<span class="dt">a =</span> , <span class="dt">b =</span> a), <span class="kw">quote</span>(a +<span class="st"> </span>b))
<span class="co">#&gt; function (a, b = a) </span>
<span class="co">#&gt; a + b</span>
<span class="co"># To take `...` as an argument put it on the LHS of =</span>
<span class="kw">make_function</span>(<span class="kw">alist</span>(<span class="dt">a =</span> , <span class="dt">b =</span> , <span class="dt">... =</span>), <span class="kw">quote</span>(a +<span class="st"> </span>b))
<span class="co">#&gt; function (a, b, ...) </span>
<span class="co">#&gt; a + b</span></code></pre>
<p><code>make_function()</code> has one advantage over using closures to construct functions: with it, you can easily read the source code. For example:</p>
<pre class="sourceCode r"><code class="sourceCode r">adder &lt;-<span class="st"> </span>function(x) {
  <span class="kw">make_function</span>(<span class="kw">alist</span>(<span class="dt">y =</span>), <span class="kw">substitute</span>({x +<span class="st"> </span>y}), <span class="kw">parent.frame</span>())
}
<span class="kw">adder</span>(<span class="dv">10</span>)
<span class="co">#&gt; function (y) </span>
<span class="co">#&gt; {</span>
<span class="co">#&gt;     10 + y</span>
<span class="co">#&gt; }</span></code></pre>
<p>One useful application of <code>make_function()</code> is in functions like <code>curve()</code>. <code>curve()</code> allows you to plot a mathematical function without creating an explicit R function:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">curve</span>(<span class="kw">sin</span>(<span class="kw">exp</span>(<span class="dv">4</span> *<span class="st"> </span>x)), <span class="dt">n =</span> <span class="dv">1000</span>)</code></pre>
<p><img src="figures/curve-demo-1.png" title="" alt="" width="336" /></p>
<p>Here <code>x</code> is a pronoun. <code>x</code> doesn’t represent a single concrete value, but is instead a placeholder that varies over the range of the plot. One way to implement <code>curve()</code> would be with <code>make_function()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">curve2 &lt;-<span class="st"> </span>function(expr, <span class="dt">xlim =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>), <span class="dt">n =</span> <span class="dv">100</span>, 
                   <span class="dt">env =</span> <span class="kw">parent.frame</span>()) {
  f &lt;-<span class="st"> </span><span class="kw">make_function</span>(<span class="kw">alist</span>(<span class="dt">x =</span> ), <span class="kw">substitute</span>(expr), env)

  x &lt;-<span class="st"> </span><span class="kw">seq</span>(xlim[<span class="dv">1</span>], xlim[<span class="dv">2</span>], <span class="dt">length =</span> n)
  y &lt;-<span class="st"> </span><span class="kw">f</span>(x)

  <span class="kw">plot</span>(x, y, <span class="dt">type =</span> <span class="st">&quot;l&quot;</span>, <span class="dt">ylab =</span> <span class="kw">deparse</span>(<span class="kw">substitute</span>(expr)))
}</code></pre>
<p>Functions that use a pronoun are called <a href="http://en.wikipedia.org/wiki/Anaphora_(linguistics)">anaphoric</a> functions. They are used in <a href="http://www.arcfn.com/doc/anaphoric.html">Arc</a> (a lisp like language), <a href="http://www.perlmonks.org/index.pl?node_id=666047">Perl</a>, and <a href="http://amalloy.hubpages.com/hub/Unhygenic-anaphoric-Clojure-macros-for-fun-and-profit">Clojure</a>.  </p>
<h3>Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>How are <code>alist(a)</code> and <code>alist(a = )</code> different? Think about both the input and the output.</p></li>
<li><p>Read the documentation and source code for <code>pryr::partial()</code>. What does it do? How does it work? Read the documentation and source code for <code>pryr::unenclose()</code>. What does it do and how does it work?</p></li>
<li><p>The actual implementation of <code>curve()</code> looks more like</p>
<pre class="sourceCode r"><code class="sourceCode r">curve3 &lt;-<span class="st"> </span>function(expr, <span class="dt">xlim =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>), <span class="dt">n =</span> <span class="dv">100</span>,
                   <span class="dt">env =</span> <span class="kw">parent.frame</span>()) {
  env2 &lt;-<span class="st"> </span><span class="kw">new.env</span>(<span class="dt">parent =</span> env)
  env2$x &lt;-<span class="st"> </span><span class="kw">seq</span>(xlim[<span class="dv">1</span>], xlim[<span class="dv">2</span>], <span class="dt">length =</span> n)

  y &lt;-<span class="st"> </span><span class="kw">eval</span>(<span class="kw">substitute</span>(expr), env2)
  <span class="kw">plot</span>(env2$x, y, <span class="dt">type =</span> <span class="st">&quot;l&quot;</span>, 
    <span class="dt">ylab =</span> <span class="kw">deparse</span>(<span class="kw">substitute</span>(expr)))
}</code></pre>
<p>How does this approach differ from <code>curve2()</code> defined above?</p></li>
</ol>
<h2 id="parsing-and-deparsing">Parsing and deparsing</h2>
<p>Sometimes code is represented as a string, rather than as an expression. You can convert a string to an expression with <code>parse()</code>. <code>parse()</code> is the opposite of <code>deparse()</code>: it takes a character vector and returns an expression object. The primary use of <code>parse()</code> is parsing files of code to disk, so the first argument is a file path. Note that if you have code in a character vector, you need to use the <code>text</code> argument: </p>
<pre class="sourceCode r"><code class="sourceCode r">z &lt;-<span class="st"> </span><span class="kw">quote</span>(y &lt;-<span class="st"> </span>x *<span class="st"> </span><span class="dv">10</span>)
<span class="kw">deparse</span>(z)
<span class="co">#&gt; [1] &quot;y &lt;- x * 10&quot;</span>

<span class="kw">parse</span>(<span class="dt">text =</span> <span class="kw">deparse</span>(z))
<span class="co">#&gt; expression(y &lt;- x * 10)</span></code></pre>
<p>Because there might be many top-level calls in a file, <code>parse()</code> doesn’t return just a single expression. Instead, it returns an expression object, which is essentially a list of expressions: </p>
<pre class="sourceCode r"><code class="sourceCode r">exp &lt;-<span class="st"> </span><span class="kw">parse</span>(<span class="dt">text =</span> <span class="kw">c</span>(<span class="st">&quot;</span>
<span class="st">  x &lt;- 4</span>
<span class="st">  x</span>
<span class="st">  5</span>
<span class="st">&quot;</span>))
<span class="kw">length</span>(exp)
<span class="co">#&gt; [1] 3</span>
<span class="kw">typeof</span>(exp)
<span class="co">#&gt; [1] &quot;expression&quot;</span>

exp[[<span class="dv">1</span>]]
<span class="co">#&gt; x &lt;- 4</span>
exp[[<span class="dv">2</span>]]
<span class="co">#&gt; x</span></code></pre>
<p>You can create expression objects by hand with <code>expression()</code>, but I wouldn’t recommend it. There’s no need to learn about this esoteric data structure if you already know how to use expressions. </p>
<p>With <code>parse()</code> and <code>eval()</code>, it’s possible to write a simple version of <code>source()</code>. We read in the file from disk, <code>parse()</code> it and then <code>eval()</code> each component in a specified environment. This version defaults to a new environment, so it doesn’t affect existing objects. <code>source()</code> invisibly returns the result of the last expression in the file, so <code>simple_source()</code> does the same. </p>
<pre class="sourceCode r"><code class="sourceCode r">simple_source &lt;-<span class="st"> </span>function(file, <span class="dt">envir =</span> <span class="kw">new.env</span>()) {
  <span class="kw">stopifnot</span>(<span class="kw">file.exists</span>(file))
  <span class="kw">stopifnot</span>(<span class="kw">is.environment</span>(envir))

  lines &lt;-<span class="st"> </span><span class="kw">readLines</span>(file, <span class="dt">warn =</span> <span class="ot">FALSE</span>)
  exprs &lt;-<span class="st"> </span><span class="kw">parse</span>(<span class="dt">text =</span> lines)

  n &lt;-<span class="st"> </span><span class="kw">length</span>(exprs)
  if (n ==<span class="st"> </span>0L) <span class="kw">return</span>(<span class="kw">invisible</span>())

  for (i in <span class="kw">seq_len</span>(n -<span class="st"> </span><span class="dv">1</span>)) {
    <span class="kw">eval</span>(exprs[i], envir)
  }
  <span class="kw">invisible</span>(<span class="kw">eval</span>(exprs[n], envir))
}</code></pre>
<p>The real <code>source()</code> is considerably more complicated because it can <code>echo</code> input and output, and also has many additional settings to control behaviour.</p>
<h3>Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>What are the differences between <code>quote()</code> and <code>expression()</code>?</p></li>
<li><p>Read the help for <code>deparse()</code> and construct a call that <code>deparse()</code> and <code>parse()</code> do not operate symmetrically on.</p></li>
<li><p>Compare and contrast <code>source()</code> and <code>sys.source()</code>.</p></li>
<li><p>Modify <code>simple_source()</code> so it returns the result of <em>every</em> expression, not just the last one.</p></li>
<li><p>The code generated by <code>simple_source()</code> lacks source references. Read the source code for <code>sys.source()</code> and the help for <code>srcfilecopy()</code>, then modify <code>simple_source()</code> to preserve source references. You can test your code by sourcing a function that contains a comment. If successful, when you look at the function, you’ll see the comment and not just the source code.</p></li>
</ol>
<h2 id="ast-funs">Walking the AST with recursive functions</h2>
<p>It’s easy to modify a single call with <code>substitute()</code> or <code>pryr::modify_call()</code>. For more complicated tasks we need to work directly with the AST. The base <code>codetools</code> package provides some useful motivating examples of how we can do this: </p>
<ul>
<li><p><code>findGlobals()</code> locates all global variables used by a function. This can be useful if you want to check that your function doesn’t inadvertently rely on variables defined in their parent environment.</p></li>
<li><p><code>checkUsage()</code> checks for a range of common problems including unused local variables, unused parameters, and the use of partial argument matching.</p></li>
</ul>
<p>To write functions like <code>findGlobals()</code> and <code>checkUsage()</code>, we’ll need a new tool. Because expressions have a tree structure, using a recursive function would be the natural choice. The key to doing that is getting the recursion right. This means making sure that you know what the base case is and figuring out how to combine the results from the recursive case. For calls, there are two base cases (atomic vectors and names) and two recursive cases (calls and pairlists). This means that a function for working with expressions will look like:</p>
<pre class="sourceCode r"><code class="sourceCode r">recurse_call &lt;-<span class="st"> </span>function(x) {
  if (<span class="kw">is.atomic</span>(x)) {
    <span class="co"># Return a value</span>
  } else if (<span class="kw">is.name</span>(x)) {
    <span class="co"># Return a value</span>
  } else if (<span class="kw">is.call</span>(x)) {
    <span class="co"># Call recurse_call recursively</span>
  } else if (<span class="kw">is.pairlist</span>(x)) {
    <span class="co"># Call recurse_call recursively</span>
  } else {
    <span class="co"># User supplied incorrect input</span>
    <span class="kw">stop</span>(<span class="st">&quot;Don&#39;t know how to handle type &quot;</span>, <span class="kw">typeof</span>(x), 
      <span class="dt">call. =</span> <span class="ot">FALSE</span>)
  }
}</code></pre>
<h3>Finding F and T</h3>
<p>We’ll start simple with a function that determines whether a function uses the logical abbreviations <code>T</code> and <code>F</code>. Using <code>T</code> and <code>F</code> is generally considered to be poor coding practice, and is something that <code>R CMD check</code> will warn about. Let’s first compare the AST for <code>T</code> vs. <code>TRUE</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ast</span>(<span class="ot">TRUE</span>)
<span class="co">#&gt; \-  TRUE</span>
<span class="kw">ast</span>(T)
<span class="co">#&gt; \- `T</span></code></pre>
<p><code>TRUE</code> is parsed as a logical vector of length one, while <code>T</code> is parsed as a name. This tells us how to write our base cases for the recursive function: while an atomic vector will never be a logical abbreviation, a name might, so we’ll need to test for both <code>T</code> and <code>F</code>. The recursive cases can be combined because they do the same thing in both cases: they recursively call <code>logical_abbr()</code> on each element of the object. </p>
<pre class="sourceCode r"><code class="sourceCode r">logical_abbr &lt;-<span class="st"> </span>function(x) {
  if (<span class="kw">is.atomic</span>(x)) {
    <span class="ot">FALSE</span>
  } else if (<span class="kw">is.name</span>(x)) {
    <span class="kw">identical</span>(x, <span class="kw">quote</span>(T)) ||<span class="st"> </span><span class="kw">identical</span>(x, <span class="kw">quote</span>(F))
  } else if (<span class="kw">is.call</span>(x) ||<span class="st"> </span><span class="kw">is.pairlist</span>(x)) {
    for (i in <span class="kw">seq_along</span>(x)) {
      if (<span class="kw">logical_abbr</span>(x[[i]])) <span class="kw">return</span>(<span class="ot">TRUE</span>)
    }
    <span class="ot">FALSE</span>
  } else {
    <span class="kw">stop</span>(<span class="st">&quot;Don&#39;t know how to handle type &quot;</span>, <span class="kw">typeof</span>(x), 
      <span class="dt">call. =</span> <span class="ot">FALSE</span>)
  }
}

<span class="kw">logical_abbr</span>(<span class="kw">quote</span>(<span class="ot">TRUE</span>))
<span class="co">#&gt; [1] FALSE</span>
<span class="kw">logical_abbr</span>(<span class="kw">quote</span>(T))
<span class="co">#&gt; [1] TRUE</span>
<span class="kw">logical_abbr</span>(<span class="kw">quote</span>(<span class="kw">mean</span>(x, <span class="dt">na.rm =</span> T)))
<span class="co">#&gt; [1] TRUE</span>
<span class="kw">logical_abbr</span>(<span class="kw">quote</span>(function(x, <span class="dt">na.rm =</span> T) <span class="ot">FALSE</span>))
<span class="co">#&gt; [1] TRUE</span></code></pre>
<h3>Finding all variables created by assignment</h3>
<p><code>logical_abbr()</code> is very simple: it only returns a single <code>TRUE</code> or <code>FALSE</code>. The next task, listing all variables created by assignment, is a little more complicated. We’ll start simply, and then make the function progressively more rigorous. </p>
<p>Again, we start by looking at the AST for assignment:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ast</span>(x &lt;-<span class="st"> </span><span class="dv">10</span>)
<span class="co">#&gt; \- ()</span>
<span class="co">#&gt;   \- `&lt;-</span>
<span class="co">#&gt;   \- `x</span>
<span class="co">#&gt;   \-  10</span></code></pre>
<p>Assignment is a call where the first element is the name <code>&lt;-</code>, the second is the object the name is assigned to, and the third is the value to be assigned. This makes the base cases simple: constants and names don’t create assignments, so they return <code>NULL</code>. The recursive cases aren’t too hard either. We <code>lapply()</code> over pairlists and over calls to functions other than <code>&lt;-</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">find_assign &lt;-<span class="st"> </span>function(x) {
  if (<span class="kw">is.atomic</span>(x) ||<span class="st"> </span><span class="kw">is.name</span>(x)) {
    <span class="ot">NULL</span>
  } else if (<span class="kw">is.call</span>(x)) {
    if (<span class="kw">identical</span>(x[[<span class="dv">1</span>]], <span class="kw">quote</span>(<span class="st">`</span><span class="dt">&lt;-</span><span class="st">`</span>))) {
      x[[<span class="dv">2</span>]]
    } else {
      <span class="kw">lapply</span>(x, find_assign)
    }
  } else if (<span class="kw">is.pairlist</span>(x)) {
    <span class="kw">lapply</span>(x, find_assign)
  } else {
    <span class="kw">stop</span>(<span class="st">&quot;Don&#39;t know how to handle type &quot;</span>, <span class="kw">typeof</span>(x), 
      <span class="dt">call. =</span> <span class="ot">FALSE</span>)
  }
}
<span class="kw">find_assign</span>(<span class="kw">quote</span>(a &lt;-<span class="st"> </span><span class="dv">1</span>))
<span class="co">#&gt; a</span>
<span class="kw">find_assign</span>(<span class="kw">quote</span>({
  a &lt;-<span class="st"> </span><span class="dv">1</span>
  b &lt;-<span class="st"> </span><span class="dv">2</span>
}))
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; NULL</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; a</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[3]]</span>
<span class="co">#&gt; b</span></code></pre>
<p>This function works for these simple cases, but the output is rather verbose and includes some extraneous <code>NULL</code>s. Instead of returning a list, let’s keep it simple and use a character vector. We’ll also test it with two slightly more complicated examples:</p>
<pre class="sourceCode r"><code class="sourceCode r">find_assign2 &lt;-<span class="st"> </span>function(x) {
  if (<span class="kw">is.atomic</span>(x) ||<span class="st"> </span><span class="kw">is.name</span>(x)) {
    <span class="kw">character</span>()
  } else if (<span class="kw">is.call</span>(x)) {
    if (<span class="kw">identical</span>(x[[<span class="dv">1</span>]], <span class="kw">quote</span>(<span class="st">`</span><span class="dt">&lt;-</span><span class="st">`</span>))) {
      <span class="kw">as.character</span>(x[[<span class="dv">2</span>]])
    } else {
      <span class="kw">unlist</span>(<span class="kw">lapply</span>(x, find_assign2))
    }
  } else if (<span class="kw">is.pairlist</span>(x)) {
    <span class="kw">unlist</span>(<span class="kw">lapply</span>(x, find_assign2))
  } else {
    <span class="kw">stop</span>(<span class="st">&quot;Don&#39;t know how to handle type &quot;</span>, <span class="kw">typeof</span>(x), 
      <span class="dt">call. =</span> <span class="ot">FALSE</span>)
  }
}

<span class="kw">find_assign2</span>(<span class="kw">quote</span>({
  a &lt;-<span class="st"> </span><span class="dv">1</span>
  b &lt;-<span class="st"> </span><span class="dv">2</span>
  a &lt;-<span class="st"> </span><span class="dv">3</span>
}))
<span class="co">#&gt; [1] &quot;a&quot; &quot;b&quot; &quot;a&quot;</span>

<span class="kw">find_assign2</span>(<span class="kw">quote</span>({
  <span class="kw">system.time</span>(x &lt;-<span class="st"> </span><span class="kw">print</span>(y &lt;-<span class="st"> </span><span class="dv">5</span>))
}))
<span class="co">#&gt; [1] &quot;x&quot;</span></code></pre>
<p>This is better, but we have two problems: dealing with repeated names and neglecting assignments inside other assignments. The fix for the first problem is easy. We need to wrap <code>unique()</code> around the recursive case to remove duplicate assignments. The fix for the second problem is a bit more tricky. We also need to recurse when the call is to <code>&lt;-</code>. <code>find_assign3()</code> implements both strategies:</p>
<pre class="sourceCode r"><code class="sourceCode r">find_assign3 &lt;-<span class="st"> </span>function(x) {
  if (<span class="kw">is.atomic</span>(x) ||<span class="st"> </span><span class="kw">is.name</span>(x)) {
    <span class="kw">character</span>()
  } else if (<span class="kw">is.call</span>(x)) {
    if (<span class="kw">identical</span>(x[[<span class="dv">1</span>]], <span class="kw">quote</span>(<span class="st">`</span><span class="dt">&lt;-</span><span class="st">`</span>))) {
      lhs &lt;-<span class="st"> </span><span class="kw">as.character</span>(x[[<span class="dv">2</span>]])
    } else {
      lhs &lt;-<span class="st"> </span><span class="kw">character</span>()
    }

    <span class="kw">unique</span>(<span class="kw">c</span>(lhs, <span class="kw">unlist</span>(<span class="kw">lapply</span>(x, find_assign3))))
  } else if (<span class="kw">is.pairlist</span>(x)) {
    <span class="kw">unique</span>(<span class="kw">unlist</span>(<span class="kw">lapply</span>(x, find_assign3)))
  } else {
    <span class="kw">stop</span>(<span class="st">&quot;Don&#39;t know how to handle type &quot;</span>, <span class="kw">typeof</span>(x), 
      <span class="dt">call. =</span> <span class="ot">FALSE</span>)
  }
}

<span class="kw">find_assign3</span>(<span class="kw">quote</span>({
  a &lt;-<span class="st"> </span><span class="dv">1</span>
  b &lt;-<span class="st"> </span><span class="dv">2</span>
  a &lt;-<span class="st"> </span><span class="dv">3</span>
}))
<span class="co">#&gt; [1] &quot;a&quot; &quot;b&quot;</span>

<span class="kw">find_assign3</span>(<span class="kw">quote</span>({
  <span class="kw">system.time</span>(x &lt;-<span class="st"> </span><span class="kw">print</span>(y &lt;-<span class="st"> </span><span class="dv">5</span>))
}))
<span class="co">#&gt; [1] &quot;x&quot; &quot;y&quot;</span></code></pre>
<p>We also need to test subassignment:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">find_assign3</span>(<span class="kw">quote</span>({
  l &lt;-<span class="st"> </span><span class="kw">list</span>()
  l$a &lt;-<span class="st"> </span><span class="dv">5</span>
  <span class="kw">names</span>(l) &lt;-<span class="st"> &quot;b&quot;</span>
}))
<span class="co">#&gt; [1] &quot;l&quot;     &quot;$&quot;     &quot;a&quot;     &quot;names&quot;</span></code></pre>
<p>We only want assignment of the object itself, not assignment that modifies a property of the object. Drawing the tree for the quoted object will help us see what condition to test for. The second element of the call to <code>&lt;-</code> should be a name, not another call.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ast</span>(l$a &lt;-<span class="st"> </span><span class="dv">5</span>)
<span class="co">#&gt; \- ()</span>
<span class="co">#&gt;   \- `&lt;-</span>
<span class="co">#&gt;   \- ()</span>
<span class="co">#&gt;     \- `$</span>
<span class="co">#&gt;     \- `l</span>
<span class="co">#&gt;     \- `a</span>
<span class="co">#&gt;   \-  5</span>
<span class="kw">ast</span>(<span class="kw">names</span>(l) &lt;-<span class="st"> &quot;b&quot;</span>)
<span class="co">#&gt; \- ()</span>
<span class="co">#&gt;   \- `&lt;-</span>
<span class="co">#&gt;   \- ()</span>
<span class="co">#&gt;     \- `names</span>
<span class="co">#&gt;     \- `l</span>
<span class="co">#&gt;   \-  &quot;b&quot;</span></code></pre>
<p>Now we have a complete version:</p>
<pre class="sourceCode r"><code class="sourceCode r">find_assign4 &lt;-<span class="st"> </span>function(x) {
  if (<span class="kw">is.atomic</span>(x) ||<span class="st"> </span><span class="kw">is.name</span>(x)) {
    <span class="kw">character</span>()
  } else if (<span class="kw">is.call</span>(x)) {
    if (<span class="kw">identical</span>(x[[<span class="dv">1</span>]], <span class="kw">quote</span>(<span class="st">`</span><span class="dt">&lt;-</span><span class="st">`</span>)) &amp;&amp;<span class="st"> </span><span class="kw">is.name</span>(x[[<span class="dv">2</span>]])) {
      lhs &lt;-<span class="st"> </span><span class="kw">as.character</span>(x[[<span class="dv">2</span>]])
    } else {
      lhs &lt;-<span class="st"> </span><span class="kw">character</span>()
    }

    <span class="kw">unique</span>(<span class="kw">c</span>(lhs, <span class="kw">unlist</span>(<span class="kw">lapply</span>(x, find_assign4))))
  } else if (<span class="kw">is.pairlist</span>(x)) {
    <span class="kw">unique</span>(<span class="kw">unlist</span>(<span class="kw">lapply</span>(x, find_assign4)))
  } else {
    <span class="kw">stop</span>(<span class="st">&quot;Don&#39;t know how to handle type &quot;</span>, <span class="kw">typeof</span>(x), 
      <span class="dt">call. =</span> <span class="ot">FALSE</span>)
  }
}

<span class="kw">find_assign4</span>(<span class="kw">quote</span>({
  l &lt;-<span class="st"> </span><span class="kw">list</span>()
  l$a &lt;-<span class="st"> </span><span class="dv">5</span>
  <span class="kw">names</span>(l) &lt;-<span class="st"> &quot;b&quot;</span>
}))
<span class="co">#&gt; [1] &quot;l&quot;</span></code></pre>
<p>While the complete version of this function is quite complicated, it’s important to remember we wrote it by working our way up by writing simple component parts.</p>
<h3 id="modifying-code">Modifying the call tree</h3>
<p>The next step up in complexity is returning a modified call tree, like what you get with <code>bquote()</code>. <code>bquote()</code> is a slightly more flexible form of quote: it allows you to optionally quote and unquote some parts of an expression (it’s similar to the backtick operator in Lisp). Everything is quoted, <em>unless</em> it’s encapsulated in <code>.()</code> in which case it’s evaluated and the result is inserted: </p>
<pre class="sourceCode r"><code class="sourceCode r">a &lt;-<span class="st"> </span><span class="dv">1</span>
b &lt;-<span class="st"> </span><span class="dv">3</span>
<span class="kw">bquote</span>(a +<span class="st"> </span>b)
<span class="co">#&gt; a + b</span>
<span class="kw">bquote</span>(a +<span class="st"> </span>.(b))
<span class="co">#&gt; a + 3</span>
<span class="kw">bquote</span>(.(a) +<span class="st"> </span>.(b))
<span class="co">#&gt; 1 + 3</span>
<span class="kw">bquote</span>(.(a +<span class="st"> </span>b))
<span class="co">#&gt; [1] 4</span></code></pre>
<p>This provides a fairly easy way to control what gets evaluated and when. How does <code>bquote()</code> work? Below, I’ve rewritten <code>bquote()</code> to use the same style as our other functions: it expects input to be quoted already, and makes the base and recursive cases more explicit:</p>
<pre class="sourceCode r"><code class="sourceCode r">bquote2 &lt;-<span class="st"> </span>function (x, <span class="dt">where =</span> <span class="kw">parent.frame</span>()) {
  if (<span class="kw">is.atomic</span>(x) ||<span class="st"> </span><span class="kw">is.name</span>(x)) {
    <span class="co"># Leave unchanged</span>
    x
  } else if (<span class="kw">is.call</span>(x)) {
    if (<span class="kw">identical</span>(x[[<span class="dv">1</span>]], <span class="kw">quote</span>(.))) {
      <span class="co"># Call to .(), so evaluate</span>
      <span class="kw">eval</span>(x[[<span class="dv">2</span>]], where)
    } else {
      <span class="co"># Otherwise apply recursively, turning result back into call</span>
      <span class="kw">as.call</span>(<span class="kw">lapply</span>(x, bquote2, <span class="dt">where =</span> where))
    }
  } else if (<span class="kw">is.pairlist</span>(x)) {
    <span class="kw">as.pairlist</span>(<span class="kw">lapply</span>(x, bquote2, <span class="dt">where =</span> where))
  } else {
    <span class="co"># User supplied incorrect input</span>
    <span class="kw">stop</span>(<span class="st">&quot;Don&#39;t know how to handle type &quot;</span>, <span class="kw">typeof</span>(x), 
      <span class="dt">call. =</span> <span class="ot">FALSE</span>)
  }
}

x &lt;-<span class="st"> </span><span class="dv">1</span>
y &lt;-<span class="st"> </span><span class="dv">2</span>
<span class="kw">bquote2</span>(<span class="kw">quote</span>(x ==<span class="st"> </span>.(x)))
<span class="co">#&gt; x == 1</span>
<span class="kw">bquote2</span>(<span class="kw">quote</span>(function(<span class="dt">x =</span> .(x)) {
  x +<span class="st"> </span>.(y)
}))
<span class="co">#&gt; function(x = 1) {</span>
<span class="co">#&gt;     x + 2</span>
<span class="co">#&gt; }</span></code></pre>
<p>The main difference between this and the previous recursive functions is that after we process each element of calls and pairlists, we need to coerce them back to their original types.</p>
<p>Note that functions that modify the source tree are most useful for creating expressions that are used at run-time, rather than those that are saved back to the original source file. This is because all non-code information is lost:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">bquote2</span>(<span class="kw">quote</span>(function(<span class="dt">x =</span> .(x)) {
  <span class="co"># This is a comment</span>
  x +<span class="st">  </span><span class="co"># funky spacing</span>
<span class="st">    </span>.(y)
}))
<span class="co">#&gt; function(x = 1) {</span>
<span class="co">#&gt;     x + 2</span>
<span class="co">#&gt; }</span></code></pre>
<p>These tools are somewhat similar to Lisp macros, as discussed in <a href="http://www.r-project.org/doc/Rnews/Rnews_2001-3.pdf#page=10">Programmer’s Niche: Macros in R</a> by Thomas Lumley. However, macros are run at compile-time, which doesn’t have any meaning in R, and always return expressions. They’re also somewhat like Lisp <a href="http://en.wikipedia.org/wiki/Fexpr">fexprs</a>. A fexpr is a function where the arguments are not evaluated by default. The terms macro and fexpr are useful to know when looking for useful techniques from other languages.  </p>
<h3>Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Why does <code>logical_abbr()</code> use a for loop instead of a functional like <code>lapply()</code>?</p></li>
<li><p><code>logical_abbr()</code> works when given quoted objects, but doesn’t work when given an existing function, as in the example below. Why not? How could you modify <code>logical_abbr()</code> to work with functions? Think about what components make up a function.</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span>function(<span class="dt">x =</span> <span class="ot">TRUE</span>) {
  <span class="kw">g</span>(x +<span class="st"> </span>T)
}
<span class="kw">logical_abbr</span>(f)</code></pre></li>
<li><p>Write a function called <code>ast_type()</code> that returns either “constant”, “name”, “call”, or “pairlist”. Rewrite <code>logical_abbr()</code>, <code>find_assign()</code>, and <code>bquote2()</code> to use this function with <code>switch()</code> instead of nested if statements.</p></li>
<li><p>Write a function that extracts all calls to a function. Compare your function to <code>pryr::fun_calls()</code>.</p></li>
<li><p>Write a wrapper around <code>bquote2()</code> that does non-standard evaluation so that you don’t need to explicitly <code>quote()</code> the input.</p></li>
<li><p>Compare <code>bquote2()</code> to <code>bquote()</code>. There is a subtle bug in <code>bquote()</code>: it won’t replace calls to functions with no arguments. Why?</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">bquote</span>(.(x)(), <span class="kw">list</span>(<span class="dt">x =</span> <span class="kw">quote</span>(f)))
<span class="co">#&gt; .(x)()</span>
<span class="kw">bquote</span>(.(x)(<span class="dv">1</span>), <span class="kw">list</span>(<span class="dt">x =</span> <span class="kw">quote</span>(f)))
<span class="co">#&gt; f(1)</span></code></pre></li>
<li><p>Improve the base <code>recurse_call()</code> template to also work with lists of functions and expressions (e.g., as from <code>parse(path_to_file))</code>.</p></li>
</ol>

        </div>
      </div>

      <div class="footer">
        <hr>
        <p>&copy; Hadley Wickham. Powered by <a href="http://jekyllrb.com/">jekyll</a>,
          <a href="http://yihui.name/knitr/">knitr</a>, and
          <a href="http://johnmacfarlane.net/pandoc/">pandoc</a>. Source
          available on <a href="https://github.com/hadley/adv-r/">github</a>.
        </p>
      </div>

    </div> <!-- /container -->

  <script src="//code.jquery.com/jquery.js"></script>
  <script src="www/bootstrap.min.js"></script>
  <script src="www/toc.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-67989-16', 'had.co.nz');
    ga('send', 'pageview');

  </script>
  </body>
</html>
