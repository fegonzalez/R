<!DOCTYPE html>
<html>
  <head>
    <title>Functionals &middot; Advanced R.</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="www/bootstrap.min.css" rel="stylesheet">
    <link href="www/highlight.css" rel="stylesheet">

    <link href='http://fonts.googleapis.com/css?family=Inconsolata:400,700'
      rel='stylesheet' type='text/css'>
  </head>

  <body>

    <div class="container">

      <div class="masthead">
        <ul class="nav nav-pills pull-right">
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">
              Table of contents<b class="caret"></b>
            </a>
            <ul class="dropdown-menu pull-right" role="menu">
              <li><a href="Introduction.html">Introduction</a></li>
<li class="dropdown-header">Foundations</li>
<li><a href="Data-structures.html">Data structures</a></li>
<li><a href="Subsetting.html">Subsetting</a></li>
<li><a href="Vocabulary.html">Vocabulary</a></li>
<li><a href="Style.html">Style</a></li>
<li><a href="Functions.html">Functions</a></li>
<li><a href="OO-essentials.html">OO field guide</a></li>
<li><a href="Environments.html">Environments</a></li>
<li><a href="Exceptions-Debugging.html">Exceptions and debugging</a></li>

<li class="dropdown-header">Functional programming</li>
<li><a href="Functional-programming.html">Functional programming</a></li>
<li><a href="Functionals.html">Functionals</a></li>
<li><a href="Function-operators.html">Function operators</a></li>

<li class="dropdown-header">Metaprogramming</li>
<li><a href="Computing-on-the-language.html">Non-standard evaluation</a></li>
<li><a href="Expressions.html">Expressions</a></li>
<li><a href="dsl.html">Domain specific languages</a></li>

<li class="dropdown-header">Performant code</li>
<li><a href="Performance.html">Performance</a></li>
<li><a href="Profiling.html">Profiling</a></li>
<li><a href="memory.html">Memory</a></li>
<li><a href="Rcpp.html">Rcpp</a></li>
<li><a href="C-interface.html">R's C interface</a></li>

            </ul>
          </li>
        </ul>

        <h3 class="muted"><a href="/">Advanced R</a> <small>by Hadley Wickham</small></h3>
        <hr>
      </div>

      <div class="row">
        <div class="col-xs-12 col-sm-3" id="nav">
        <div class="well">
          Want to learn from me in person? I'm next teaching in <a href="https://rstudio-chicago.eventbrite.com">Chicago, May 27-28</a>.
        </div>

        <div class="well">
          Want a physical copy of this material? <a href="http://amzn.com/1466586966?tag=devtools-20">Buy a book from amazon!</a>.
        </div>

        <h4>Contents</h4>
          <ul class="list-unstyled" id="toc"></ul>

          <hr>
          <p><a href="/contribute.html">How to contribute</a></p>

          <p><a class="btn btn-primary" href="https://github.com/hadley/adv-r/edit/master/Functionals.rmd">Edit this page</a></p>
        </div>

        <div id="content" class="col-xs-12 col-sm-8 pull-right">
          <h1 id="functionals">Functionals</h1>
<blockquote>
<p>“To become significantly more reliable, code must become more transparent. In particular, nested conditions and loops must be viewed with great suspicion. Complicated control flows confuse programmers. Messy code often hides bugs.”</p>
<p>— Bjarne Stroustrup</p>
</blockquote>
<p>A higher-order function is a function that takes a function as an input or returns a function as output. We’ve already seen one type of higher order function: closures, functions returned by another function. The complement to a closure is a <strong>functional</strong>, a function that takes a function as an input and returns a vector as output. Here’s a simple functional: it calls the function provided as input with 1000 random uniform numbers. </p>
<pre class="sourceCode r"><code class="sourceCode r">randomise &lt;-<span class="st"> </span>function(f) <span class="kw">f</span>(<span class="kw">runif</span>(<span class="fl">1e3</span>))
<span class="kw">randomise</span>(mean)
<span class="co">#&gt; [1] 0.5035198</span>
<span class="kw">randomise</span>(mean)
<span class="co">#&gt; [1] 0.506801</span>
<span class="kw">randomise</span>(sum)
<span class="co">#&gt; [1] 504.3463</span></code></pre>
<p>The chances are that you’ve already used a functional: the three most frequently used are <code>lapply()</code>, <code>apply()</code>, and <code>tapply()</code>. All three take a function as input (among other things) and return a vector as output.</p>
<p>A common use of functionals is as an alternative to for loops. For loops have a bad rap in R. They have a reputation for being slow (although that reputation is only partly true, see <a href="memory.html#modification">modification in place</a> for more details). But the real downside of for loops is that they’re not very expressive. A for loop conveys that it’s iterating over something, but doesn’t clearly convey a high level goal. Instead of using a for loop, it’s better to use a functional. Each functional is tailored for a specific task, so when you recognise the functional you know immediately why it’s being used. Functionals play other roles as well as replacements for for-loops. They are useful for encapsulating common data manipulation tasks like split-apply-combine, for thinking “functionally”, and for working with mathematical functions. </p>
<p>Functionals reduce bugs in your code by better communicating intent. Functionals implemented in base R are well tested (i.e., bug-free) and efficient, because they’re used by so many people. Many are written in C, and use special tricks to enhance performance. That said, using functionals will not always produce the fastest code. Instead, it helps you clearly communicate and build tools that solve a wide range of problems. It’s a mistake to focus on speed until you know it’ll be a problem. Once you have clear, correct code you can make it fast using the techniques you’ll learn in <a href="Profiling.html#profiling">improving the speed of your code</a>.</p>
<h5>Outline</h5>
<ul>
<li><p><a href="Functionals.html#lapply">My first functional: lapply()</a> introduces your first functional: <code>lapply()</code>.</p></li>
<li><p><a href="Functionals.html#functionals-loop">For loop functionals</a> shows you variants of <code>lapply()</code> that produce different outputs, take different inputs, and distribute computation in different ways.</p></li>
<li><p><a href="Functionals.html#functionals-ds">Data structure functionals</a> discusses functionals that work with more complex data structures like matrices and arrays.</p></li>
<li><p><a href="Functionals.html#functionals-fp">Functional programming</a> teaches you about the powerful <code>Reduce()</code> and <code>Filter()</code> functions which are useful for working with lists.</p></li>
<li><p><a href="Functionals.html#functionals-math">Mathematical functionals</a> discusses functionals that you might be familiar with from mathematics, like root finding, integration, and optimisation.</p></li>
<li><p><a href="Functionals.html#functionals-not">Loops that shouldn’t be converted to functions</a> provides some important caveats about when you shouldn’t attempt to convert a loop into a functional.</p></li>
<li><p><a href="Functionals.html#function-family">A family of functions</a> finishes off the chapter by showing you how functionals can take a simple building block and use it to create a set of powerful and consistent tools.</p></li>
</ul>
<h5>Prerequisites</h5>
<p>You’ll use closures frequently used in conjunction with functionals. If you need a refresher, review <a href="Functional-programming.html#closures">closures</a>.</p>
<h2 id="lapply">My first functional: lapply()</h2>
<p>The simplest functional is <code>lapply()</code>, which you may already be familiar with. <code>lapply()</code> takes a function, applies it to each element in a list, and returns the results in the form of a list. <code>lapply()</code> is the building block for many other functionals, so it’s important to understand how it works. Here’s a pictorial representation: </p>
<p><img src='diagrams/lapply.png' width=230 height=195 /></p>
<p><code>lapply()</code> is written in C for performance, but we can create a simple R implementation that does the same thing:</p>
<pre class="sourceCode r"><code class="sourceCode r">lapply2 &lt;-<span class="st"> </span>function(x, f, ...) {
  out &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, <span class="kw">length</span>(x))
  for (i in <span class="kw">seq_along</span>(x)) {
    out[[i]] &lt;-<span class="st"> </span><span class="kw">f</span>(x[[i]], ...)
  }
  out
}</code></pre>
<p>From this code, you can see that <code>lapply()</code> is a wrapper for a common for loop pattern: create a container for output, apply <code>f()</code> to each component of a list, and fill the container with the results. All other for loop functionals are variations on this theme: they simply use different types of input or output.</p>
<p><code>lapply()</code> makes it easier to work with lists by eliminating much of the boilerplate associated with looping. This allows you to focus on the function that you’re applying:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Create some random data</span>
l &lt;-<span class="st"> </span><span class="kw">replicate</span>(<span class="dv">20</span>, <span class="kw">runif</span>(<span class="kw">sample</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="dv">1</span>)), <span class="dt">simplify =</span> <span class="ot">FALSE</span>)

<span class="co"># With a for loop</span>
out &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, <span class="kw">length</span>(l))
for (i in <span class="kw">seq_along</span>(l)) {
  out[[i]] &lt;-<span class="st"> </span><span class="kw">length</span>(l[[i]])
}
<span class="kw">unlist</span>(out)
<span class="co">#&gt;  [1]  7 10  7  2  4  7  8  3 10  3  3  9  1 10  4  3  4  7  6  4</span>

<span class="co"># With lapply</span>
<span class="kw">unlist</span>(<span class="kw">lapply</span>(l, length))
<span class="co">#&gt;  [1]  7 10  7  2  4  7  8  3 10  3  3  9  1 10  4  3  4  7  6  4</span></code></pre>
<p>(I’m using <code>unlist()</code> to convert the output from a list to a vector to make it more compact. We’ll see other ways of making the output a vector shortly.)</p>
<p>Since data frames are also lists, <code>lapply()</code> is also useful when you want to do something to each column of a data frame: </p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># What class is each column?</span>
<span class="kw">unlist</span>(<span class="kw">lapply</span>(mtcars, class))
<span class="co">#&gt;       mpg       cyl      disp        hp      drat        wt      qsec </span>
<span class="co">#&gt; &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot; </span>
<span class="co">#&gt;        vs        am      gear      carb </span>
<span class="co">#&gt; &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot;</span>

<span class="co"># Divide each column by the mean</span>
mtcars[] &lt;-<span class="st"> </span><span class="kw">lapply</span>(mtcars, function(x) x /<span class="st"> </span><span class="kw">mean</span>(x))</code></pre>
<p>The pieces of <code>x</code> are always supplied as the first argument to <code>f</code>. If you want to vary a different argument, you can use an anonymous function. The following example varies the amount of trimming applied when computing the mean of a fixed <code>x</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">trims &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">0</span>, <span class="fl">0.1</span>, <span class="fl">0.2</span>, <span class="fl">0.5</span>)
x &lt;-<span class="st"> </span><span class="kw">rcauchy</span>(<span class="dv">1000</span>)
<span class="kw">unlist</span>(<span class="kw">lapply</span>(trims, function(trim) <span class="kw">mean</span>(x, <span class="dt">trim =</span> trim)))
<span class="co">#&gt; [1] 0.20761373 0.11815377 0.11164949 0.08993097</span></code></pre>
<h3>Looping patterns</h3>
<p>It’s useful to remember that there are three basic ways to loop over a vector: </p>
<ol style="list-style-type: decimal">
<li>loop over the elements: <code>for (x in xs)</code></li>
<li>loop over the numeric indices: <code>for (i in seq_along(xs))</code></li>
<li>loop over the names: <code>for (nm in names(xs))</code></li>
</ol>
<p>The first form is usually not a good choice for a for loop because it leads to inefficient ways of saving output. With this form it’s very natural to save the output by extending a datastructure, like in this example:</p>
<pre class="sourceCode r"><code class="sourceCode r">xs &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="fl">1e3</span>)
res &lt;-<span class="st"> </span><span class="kw">c</span>()
for (x in xs) {
  <span class="co"># This is slow!</span>
  res &lt;-<span class="st"> </span><span class="kw">c</span>(res, <span class="kw">sqrt</span>(x))
}</code></pre>
<p>This is slow because each time you extend the vector, R has to copy all of the existing elements. <a href="Profiling.html#avoid-copies">Avoid copies</a> discusses this problem in more depth. Instead, it’s much better to create the space you’ll need for the output and then fill it in. This is easiest with the second form: </p>
<pre class="sourceCode r"><code class="sourceCode r">res &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="kw">length</span>(xs))
for (i in <span class="kw">seq_along</span>(xs)) {
  res[i] &lt;-<span class="st"> </span><span class="kw">sqrt</span>(xs[i])
}</code></pre>
<p>Just as there are three basic ways to use a for loop, there are three basic ways to use <code>lapply()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">lapply</span>(xs, function(x) {})
<span class="kw">lapply</span>(<span class="kw">seq_along</span>(xs), function(i) {})
<span class="kw">lapply</span>(<span class="kw">names</span>(xs), function(nm) {})</code></pre>
<p>Typically you’d use the first form because <code>lapply()</code> takes care of saving the output for you. However, if you need to know the position or name of the element you’re working with, you should use the second or third form. Both give you an element’s position (<code>i</code>, <code>nm</code>) and value (<code>xs[[i]]</code>, <code>xs[[nm]]</code>). If you’re struggling to solve a problem using one form, you might find it easier with another.</p>
<h3>Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Why are the following two invocations of <code>lapply()</code> equivalent?</p>
<pre class="sourceCode r"><code class="sourceCode r">trims &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">0</span>, <span class="fl">0.1</span>, <span class="fl">0.2</span>, <span class="fl">0.5</span>)
x &lt;-<span class="st"> </span><span class="kw">rcauchy</span>(<span class="dv">100</span>)

<span class="kw">lapply</span>(trims, function(trim) <span class="kw">mean</span>(x, <span class="dt">trim =</span> trim))
<span class="kw">lapply</span>(trims, mean, <span class="dt">x =</span> x)</code></pre></li>
<li><p>The function below scales a vector so it falls in the range [0, 1]. How would you apply it to every column of a data frame? How would you apply it to every numeric column in a data frame?</p>
<pre class="sourceCode r"><code class="sourceCode r">scale01 &lt;-<span class="st"> </span>function(x) {
  rng &lt;-<span class="st"> </span><span class="kw">range</span>(x, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
  (x -<span class="st"> </span>rng[<span class="dv">1</span>]) /<span class="st"> </span>(rng[<span class="dv">2</span>] -<span class="st"> </span>rng[<span class="dv">1</span>])
}</code></pre></li>
<li><p>Use both for loops and <code>lapply()</code> to fit linear models to the <code>mtcars</code> using the formulas stored in this list:</p>
<pre class="sourceCode r"><code class="sourceCode r">formulas &lt;-<span class="st"> </span><span class="kw">list</span>(
  mpg ~<span class="st"> </span>disp,
  mpg ~<span class="st"> </span><span class="kw">I</span>(<span class="dv">1</span> /<span class="st"> </span>disp),
  mpg ~<span class="st"> </span>disp +<span class="st"> </span>wt,
  mpg ~<span class="st"> </span><span class="kw">I</span>(<span class="dv">1</span> /<span class="st"> </span>disp) +<span class="st"> </span>wt
)</code></pre></li>
<li><p>Fit the model <code>mpg ~ disp</code> to each of the bootstrap replicates of <code>mtcars</code> in the list below by using a for loop and <code>lapply()</code>. Can you do it without an anonymous function?</p>
<pre class="sourceCode r"><code class="sourceCode r">bootstraps &lt;-<span class="st"> </span><span class="kw">lapply</span>(<span class="dv">1</span>:<span class="dv">10</span>, function(i) {
  rows &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span>:<span class="kw">nrow</span>(mtcars), <span class="dt">rep =</span> <span class="ot">TRUE</span>)
  mtcars[rows, ]
})</code></pre></li>
<li><p>For each model in the previous two exercises, extract <span class="math"><em>R</em><sup>2</sup></span> using the function below.</p>
<pre class="sourceCode r"><code class="sourceCode r">rsq &lt;-<span class="st"> </span>function(mod) <span class="kw">summary</span>(mod)$r.squared</code></pre></li>
</ol>
<h2 id="functionals-loop">For loop functionals: friends of lapply()</h2>
<p>The key to using functionals in place of for loops is recognising that common looping patterns are already implemented in existing base functionals. Once you’ve mastered these existing functionals, the next step is to start writing your own: if you discover you’re duplicating the same looping pattern in many places, you should extract it out into its own function.</p>
<p>The following sections build on <code>lapply()</code> and discuss:</p>
<ul>
<li><p><code>sapply()</code> and <code>vapply()</code>, variants of <code>lapply()</code> that produce vectors, matrices, and arrays as <strong>output</strong>, instead of lists.</p></li>
<li><p><code>Map()</code> and <code>mapply()</code> which iterate over multiple <strong>input</strong> data structures in parallel.</p></li>
<li><p><code>mclapply()</code> and <code>mcMap()</code>, parallel versions of <code>lapply()</code> and <code>Map()</code>.</p></li>
<li><p>Writing a new function, <code>rollapply()</code>, to solve a new problem.</p></li>
</ul>
<h3>Vector output: <code>sapply</code> and <code>vapply</code></h3>
<p><code>sapply()</code> and <code>vapply()</code> are very similar to <code>lapply()</code> except they simplify their output to produce an atomic vector. While <code>sapply()</code> guesses, <code>vapply()</code> takes an additional argument specifying the output type. <code>sapply()</code> is great for interactive use because it saves typing, but if you use it inside your functions you’ll get weird errors if you supply the wrong type of input. <code>vapply()</code> is more verbose, but gives more informative error messages and never fails silently. It is better suited for use inside other functions.  </p>
<p>The following example illustrates these differences. When given a data frame, <code>sapply()</code> and <code>vapply()</code> return the same results. When given an empty list, <code>sapply()</code> returns another empty list instead of the more correct zero-length logical vector.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sapply</span>(mtcars, is.numeric)
<span class="co">#&gt;  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb </span>
<span class="co">#&gt; TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE</span>
<span class="kw">vapply</span>(mtcars, is.numeric, <span class="kw">logical</span>(<span class="dv">1</span>))
<span class="co">#&gt;  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb </span>
<span class="co">#&gt; TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE</span>
<span class="kw">sapply</span>(<span class="kw">list</span>(), is.numeric)
<span class="co">#&gt; list()</span>
<span class="kw">vapply</span>(<span class="kw">list</span>(), is.numeric, <span class="kw">logical</span>(<span class="dv">1</span>))
<span class="co">#&gt; logical(0)</span></code></pre>
<p>If the function returns results of different types or lengths, <code>sapply()</code> will silently return a list, while <code>vapply()</code> will throw an error. <code>sapply()</code> is fine for interactive use because you’ll normally notice if something goes wrong, but it’s dangerous when writing functions.</p>
<p>The following example illustrates a possible problem when extracting the class of columns in a data frame: if you falsely assume that class only has one value and use <code>sapply()</code>, you won’t find out about the problem until some future function is given a list instead of a character vector.</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">y =</span> letters[<span class="dv">1</span>:<span class="dv">10</span>])
<span class="kw">sapply</span>(df, class)
<span class="co">#&gt;         x         y </span>
<span class="co">#&gt; &quot;integer&quot;  &quot;factor&quot;</span>
<span class="kw">vapply</span>(df, class, <span class="kw">character</span>(<span class="dv">1</span>))
<span class="co">#&gt;         x         y </span>
<span class="co">#&gt; &quot;integer&quot;  &quot;factor&quot;</span>

df2 &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">y =</span> <span class="kw">Sys.time</span>() +<span class="st"> </span><span class="dv">1</span>:<span class="dv">10</span>)
<span class="kw">sapply</span>(df2, class)
<span class="co">#&gt; $x</span>
<span class="co">#&gt; [1] &quot;integer&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $y</span>
<span class="co">#&gt; [1] &quot;POSIXct&quot; &quot;POSIXt&quot;</span>
<span class="kw">vapply</span>(df2, class, <span class="kw">character</span>(<span class="dv">1</span>))
<span class="co">#&gt; Error in vapply(df2, class, character(1)): values must be length 1,</span>
<span class="co">#&gt;  but FUN(X[[2]]) result is length 2</span></code></pre>
<p><code>sapply()</code> is a thin wrapper around <code>lapply()</code> that transforms a list into a vector in the final step. <code>vapply()</code> is an implementation of <code>lapply()</code> that assigns results to a vector (or matrix) of appropriate type instead of as a list. The following code shows a pure R implementation of the essence of <code>sapply()</code> and <code>vapply()</code> (the real functions have better error handling and preserve names, among other things).</p>
<pre class="sourceCode r"><code class="sourceCode r">sapply2 &lt;-<span class="st"> </span>function(x, f, ...) {
  res &lt;-<span class="st"> </span><span class="kw">lapply2</span>(x, f, ...)
  <span class="kw">simplify2array</span>(res)
}

vapply2 &lt;-<span class="st"> </span>function(x, f, f.value, ...) {
  out &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rep</span>(f.value, <span class="kw">length</span>(x)), <span class="dt">nrow =</span> <span class="kw">length</span>(x))
  for (i in <span class="kw">seq_along</span>(x)) {
    res &lt;-<span class="st"> </span><span class="kw">f</span>(x[i], ...)
    <span class="kw">stopifnot</span>(
      <span class="kw">length</span>(res) ==<span class="st"> </span><span class="kw">length</span>(f.value),
      <span class="kw">typeof</span>(res) ==<span class="st"> </span><span class="kw">typeof</span>(f.value)
    )
    out[i, ] &lt;-<span class="st"> </span>res
  }
  out
}</code></pre>
<p><img src='diagrams/sapply-vapply.png' width=545 height=197 /></p>
<p><code>vapply()</code> and <code>sapply()</code> have different outputs from <code>lapply()</code>. The following section discusses <code>Map()</code>, which has different inputs.</p>
<h3 id="map">Multiple inputs: <code>Map</code> (and <code>mapply</code>)</h3>
<p>With <code>lapply()</code>, only one argument to the function varies; the others are fixed. This makes it poorly suited for some problems. For example, how would you find a weighted mean when you have two lists, one of observations and the other of weights? </p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Generate some sample data</span>
xs &lt;-<span class="st"> </span><span class="kw">replicate</span>(<span class="dv">5</span>, <span class="kw">runif</span>(<span class="dv">10</span>), <span class="dt">simplify =</span> <span class="ot">FALSE</span>)
ws &lt;-<span class="st"> </span><span class="kw">replicate</span>(<span class="dv">5</span>, <span class="kw">rpois</span>(<span class="dv">10</span>, <span class="dv">5</span>) +<span class="st"> </span><span class="dv">1</span>, <span class="dt">simplify =</span> <span class="ot">FALSE</span>)</code></pre>
<p>It’s easy to use <code>lapply()</code> to compute the unweighted means:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">unlist</span>(<span class="kw">lapply</span>(xs, mean))
<span class="co">#&gt; [1] 0.3625674 0.4802904 0.4953567 0.3985036 0.4395210</span></code></pre>
<p>But how could we supply the weights to <code>weighted.mean()</code>? <code>lapply(x, means, w)</code> won’t work because the additional arguments to <code>lapply()</code> are passed to every call. We could change looping forms:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">unlist</span>(<span class="kw">lapply</span>(<span class="kw">seq_along</span>(xs), function(i) {
  <span class="kw">weighted.mean</span>(xs[[i]], ws[[i]])
}))
<span class="co">#&gt; [1] 0.3471162 0.4532839 0.4802208 0.4127994 0.4349275</span></code></pre>
<p>This works, but it’s a little clumsy. A cleaner alternative is to use <code>Map</code>, a variant of <code>lapply()</code>, where all arguments can vary. This lets us write:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">unlist</span>(<span class="kw">Map</span>(weighted.mean, xs, ws))
<span class="co">#&gt; [1] 0.3471162 0.4532839 0.4802208 0.4127994 0.4349275</span></code></pre>
<p>Note that the order of arguments is a little different: function is the first argument for <code>Map()</code> and the second for <code>lapply()</code>.</p>
<p>This is equivalent to:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">stopifnot</span>(<span class="kw">length</span>(xs) ==<span class="st"> </span><span class="kw">length</span>(ws))
out &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, <span class="kw">length</span>(xs))
for (i in <span class="kw">seq_along</span>(xs)) {
  out[[i]] &lt;-<span class="st"> </span><span class="kw">weighted.mean</span>(xs[[i]], ws[[i]])
}</code></pre>
<p>There’s a natural equivalence between <code>Map()</code> and <code>lapply()</code> because you can always convert a <code>Map()</code> to an <code>lapply()</code> that iterates over indices. But using <code>Map()</code> is more concise, and more clearly indicates what you’re trying to do.</p>
<p><code>Map</code> is useful whenever you have two (or more) lists (or data frames) that you need to process in parallel. For example, another way of standardising columns is to first compute the means and then divide by them. We could do this with <code>lapply()</code>, but if we do it in two steps, we can more easily check the results at each step, which is particularly important if the first step is more complicated.</p>
<pre class="sourceCode r"><code class="sourceCode r">mtmeans &lt;-<span class="st"> </span><span class="kw">lapply</span>(mtcars, mean)
mtmeans[] &lt;-<span class="st"> </span><span class="kw">Map</span>(<span class="st">`</span><span class="dt">/</span><span class="st">`</span>, mtcars, mtmeans)

<span class="co"># In this case, equivalent to</span>
mtcars[] &lt;-<span class="st"> </span><span class="kw">lapply</span>(mtcars, function(x) x /<span class="st"> </span><span class="kw">mean</span>(x))</code></pre>
<p>If some of the arguments should be fixed and constant, use an anonymous function:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Map</span>(function(x, w) <span class="kw">weighted.mean</span>(x, w, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>), xs, ws)</code></pre>
<p>We’ll see a more compact way to express the same idea in the next chapter.</p>
<div class="sidebar">
<h3>
mapply
</h3>

<p>You may be more familiar with <code>mapply()</code> than <code>Map()</code>. I prefer <code>Map()</code> because:</p>
<ul>
<li><p>It’s equivalent to <code>mapply</code> with <code>simplify = FALSE</code>, which is almost always what you want.</p></li>
<li><p>Instead of using an anonymous function to provide constant inputs, <code>mapply</code> has the <code>MoreArgs</code> argument that takes a list of extra arguments that will be supplied, as is, to each call. This breaks R’s usual lazy evaluation semantics, and is inconsistent with other functions.</p></li>
</ul>
<p>In brief, <code>mapply()</code> adds more complication for little gain. </p>
</div>
<h3>Rolling computations</h3>
<p>What if you need a for loop replacement that doesn’t exist in base R? You can often create your own by recognising common looping structures and implementing your own wrapper. For example, you might be interested in smoothing your data using a rolling (or running) mean function: </p>
<pre class="sourceCode r"><code class="sourceCode r">rollmean &lt;-<span class="st"> </span>function(x, n) {
  out &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, <span class="kw">length</span>(x))

  offset &lt;-<span class="st"> </span><span class="kw">trunc</span>(n /<span class="st"> </span><span class="dv">2</span>)
  for (i in (offset +<span class="st"> </span><span class="dv">1</span>):(<span class="kw">length</span>(x) -<span class="st"> </span>n +<span class="st"> </span>offset +<span class="st"> </span><span class="dv">1</span>)) {
    out[i] &lt;-<span class="st"> </span><span class="kw">mean</span>(x[(i -<span class="st"> </span>offset):(i +<span class="st"> </span>offset -<span class="st"> </span><span class="dv">1</span>)])
  }
  out
}
x &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dt">length =</span> <span class="fl">1e2</span>) +<span class="st"> </span><span class="kw">runif</span>(<span class="fl">1e2</span>)
<span class="kw">plot</span>(x)
<span class="kw">lines</span>(<span class="kw">rollmean</span>(x, <span class="dv">5</span>), <span class="dt">col =</span> <span class="st">&quot;blue&quot;</span>, <span class="dt">lwd =</span> <span class="dv">2</span>)
<span class="kw">lines</span>(<span class="kw">rollmean</span>(x, <span class="dv">10</span>), <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>, <span class="dt">lwd =</span> <span class="dv">2</span>)</code></pre>
<p><img src="figures/roll-mean-1.png" title="" alt="" width="288" /></p>
<p>But if the noise was more variable (i.e., it has a longer tail), you might worry that your rolling mean was too sensitive to outliers. Instead, you might want to compute a rolling median.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dt">length =</span> <span class="fl">1e2</span>) +<span class="st"> </span><span class="kw">rt</span>(<span class="fl">1e2</span>, <span class="dt">df =</span> <span class="dv">2</span>) /<span class="st"> </span><span class="dv">3</span>
<span class="kw">plot</span>(x)
<span class="kw">lines</span>(<span class="kw">rollmean</span>(x, <span class="dv">5</span>), <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>, <span class="dt">lwd =</span> <span class="dv">2</span>)</code></pre>
<p><img src="figures/outliers-1.png" title="" alt="" width="288" /></p>
<p>To change <code>rollmean()</code> to <code>rollmedian()</code>, all you need to do is replace <code>mean</code> with <code>median</code> inside the loop. But instead of copying and pasting to create a new function, we could extract the idea of computing a rolling summary into its own function: </p>
<pre class="sourceCode r"><code class="sourceCode r">rollapply &lt;-<span class="st"> </span>function(x, n, f, ...) {
  out &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, <span class="kw">length</span>(x))

  offset &lt;-<span class="st"> </span><span class="kw">trunc</span>(n /<span class="st"> </span><span class="dv">2</span>)
  for (i in (offset +<span class="st"> </span><span class="dv">1</span>):(<span class="kw">length</span>(x) -<span class="st"> </span>n +<span class="st"> </span>offset +<span class="st"> </span><span class="dv">1</span>)) {
    out[i] &lt;-<span class="st"> </span><span class="kw">f</span>(x[(i -<span class="st"> </span>offset):(i +<span class="st"> </span>offset)], ...)
  }
  out
}
<span class="kw">plot</span>(x)
<span class="kw">lines</span>(<span class="kw">rollapply</span>(x, <span class="dv">5</span>, median), <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>, <span class="dt">lwd =</span> <span class="dv">2</span>)</code></pre>
<p><img src="figures/roll-apply-1.png" title="" alt="" width="288" /></p>
<p>You might notice that the internal loop looks pretty similar to a <code>vapply()</code> loop, so we could rewrite the function as:</p>
<pre class="sourceCode r"><code class="sourceCode r">rollapply &lt;-<span class="st"> </span>function(x, n, f, ...) {
  offset &lt;-<span class="st"> </span><span class="kw">trunc</span>(n /<span class="st"> </span><span class="dv">2</span>)
  locs &lt;-<span class="st"> </span>(offset +<span class="st"> </span><span class="dv">1</span>):(<span class="kw">length</span>(x) -<span class="st"> </span>n +<span class="st"> </span>offset +<span class="st"> </span><span class="dv">1</span>)
  num &lt;-<span class="st"> </span><span class="kw">vapply</span>(
    locs, 
    function(i) <span class="kw">f</span>(x[(i -<span class="st"> </span>offset):(i +<span class="st"> </span>offset)], ...),
    <span class="kw">numeric</span>(<span class="dv">1</span>)
  )

  <span class="kw">c</span>(<span class="kw">rep</span>(<span class="ot">NA</span>, offset), num)
}</code></pre>
<p>This is effectively the same as the implementation in <code>zoo::rollapply()</code>, which provides many more features and much more error checking.</p>
<h3>Parallelisation</h3>
<p>One interesting thing about the implementation of <code>lapply()</code> is that because each iteration is isolated from all others, the order in which they are computed doesn’t matter. For example, <code>lapply3()</code> scrambles the order of computation, but the results are always the same:  </p>
<pre class="sourceCode r"><code class="sourceCode r">lapply3 &lt;-<span class="st"> </span>function(x, f, ...) {
  out &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, <span class="kw">length</span>(x))
  for (i in <span class="kw">sample</span>(<span class="kw">seq_along</span>(x))) {
    out[[i]] &lt;-<span class="st"> </span><span class="kw">f</span>(x[[i]], ...)
  }
  out
}
<span class="kw">unlist</span>(<span class="kw">lapply</span>(<span class="dv">1</span>:<span class="dv">10</span>, sqrt))
<span class="co">#&gt;  [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751</span>
<span class="co">#&gt;  [8] 2.828427 3.000000 3.162278</span>
<span class="kw">unlist</span>(<span class="kw">lapply3</span>(<span class="dv">1</span>:<span class="dv">10</span>, sqrt))
<span class="co">#&gt;  [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751</span>
<span class="co">#&gt;  [8] 2.828427 3.000000 3.162278</span></code></pre>
<p>This has a very important consequence: since we can compute each element in any order, it’s easy to dispatch the tasks to different cores, and compute them in parallel. This is what <code>parallel::mclapply()</code> (and <code>parallel::mcMap()</code>) does. (These functions are not available in Windows, but you can use the similar <code>parLapply()</code> with a bit more work. See <a href="Profiling.html#parallelise">parallelise</a> for more details.) </p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(parallel)
<span class="kw">unlist</span>(<span class="kw">mclapply</span>(<span class="dv">1</span>:<span class="dv">10</span>, sqrt, <span class="dt">mc.cores =</span> <span class="dv">4</span>))
<span class="co">#&gt;  [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751</span>
<span class="co">#&gt;  [8] 2.828427 3.000000 3.162278</span></code></pre>
<p>In this case, <code>mclapply()</code> is actually slower than <code>lapply()</code>. This is because the cost of the individual computations is low, and additional work is needed to send the computation to the different cores and to collect the results.</p>
<p>If we take a more realistic example, generating bootstrap replicates of a linear model for example, the advantages are clearer: </p>
<pre class="sourceCode r"><code class="sourceCode r">boot_df &lt;-<span class="st"> </span>function(x) x[<span class="kw">sample</span>(<span class="kw">nrow</span>(x), <span class="dt">rep =</span> T), ]
rsquared &lt;-<span class="st"> </span>function(mod) <span class="kw">summary</span>(mod)$r.square
boot_lm &lt;-<span class="st"> </span>function(i) {
  <span class="kw">rsquared</span>(<span class="kw">lm</span>(mpg ~<span class="st"> </span>wt +<span class="st"> </span>disp, <span class="dt">data =</span> <span class="kw">boot_df</span>(mtcars)))
}

<span class="kw">system.time</span>(<span class="kw">lapply</span>(<span class="dv">1</span>:<span class="dv">500</span>, boot_lm))
<span class="co">#&gt;    user  system elapsed </span>
<span class="co">#&gt;   1.282   0.002   1.306</span>
<span class="kw">system.time</span>(<span class="kw">mclapply</span>(<span class="dv">1</span>:<span class="dv">500</span>, boot_lm, <span class="dt">mc.cores =</span> <span class="dv">2</span>))
<span class="co">#&gt;    user  system elapsed </span>
<span class="co">#&gt;   0.618   0.060   0.670</span></code></pre>
<p>While increasing the number of cores will not always lead to linear improvement, switching from <code>lapply()</code> or <code>Map()</code> to its parallelised forms can dramatically improve computational performance.</p>
<h3>Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Use <code>vapply()</code> to:</p>
<ol style="list-style-type: lower-alpha">
<li><p>Compute the standard deviation of every column in a numeric data frame.</p></li>
<li><p>Compute the standard deviation of every numeric column in a mixed data frame. (Hint: you’ll need to use <code>vapply()</code> twice.)</p></li>
</ol></li>
<li><p>Why is using <code>sapply()</code> to get the <code>class()</code> of each element in a data frame dangerous?</p></li>
<li><p>The following code simulates the performance of a t-test for non-normal data. Use <code>sapply()</code> and an anonymous function to extract the p-value from every trial.</p>
<pre class="sourceCode r"><code class="sourceCode r">trials &lt;-<span class="st"> </span><span class="kw">replicate</span>(
  <span class="dv">100</span>, 
  <span class="kw">t.test</span>(<span class="kw">rpois</span>(<span class="dv">10</span>, <span class="dv">10</span>), <span class="kw">rpois</span>(<span class="dv">7</span>, <span class="dv">10</span>)),
  <span class="dt">simplify =</span> <span class="ot">FALSE</span>
)</code></pre>
<p>Extra challenge: get rid of the anonymous function by using <code>[[</code> directly.</p></li>
<li><p>What does <code>replicate()</code> do? What sort of for loop does it eliminate? Why do its arguments differ from <code>lapply()</code> and friends?</p></li>
<li><p>Implement a version of <code>lapply()</code> that supplies <code>FUN</code> with both the name and the value of each component.</p></li>
<li><p>Implement a combination of <code>Map()</code> and <code>vapply()</code> to create an <code>lapply()</code> variant that iterates in parallel over all of its inputs and stores its outputs in a vector (or a matrix). What arguments should the function take?</p></li>
<li><p>Implement <code>mcsapply()</code>, a multicore version of <code>sapply()</code>. Can you implement <code>mcvapply()</code>, a parallel version of <code>vapply()</code>? Why or why not?</p></li>
</ol>
<h2 id="functionals-ds">Manipulating matrices and data frames</h2>
<p>Functionals can also be used to eliminate loops in common data manipulation tasks. In this section, we’ll give a brief overview of the available options, hint at how they can help you, and point you in the right direction to learn more. We’ll cover three categories of data structure functionals:</p>
<ul>
<li><p><code>apply()</code>, <code>sweep()</code>, and <code>outer()</code> work with matrices.</p></li>
<li><p><code>tapply()</code> summarises a vector by groups defined by another vector.</p></li>
<li><p>the <code>plyr</code> package, which generalises <code>tapply()</code> to make it easy to work with data frames, lists, or arrays as inputs, and data frames, lists, or arrays as outputs.</p></li>
</ul>
<h3>Matrix and array operations</h3>
<p>So far, all the functionals we’ve seen work with 1d input structures. The three functionals in this section provide useful tools for working with higher-dimensional data structures. <code>apply()</code> is a variant of <code>sapply()</code> that works with matrices and arrays. You can think of it as an operation that summarises a matrix or array by collapsing each row or column to a single number. It has four arguments: </p>
<ul>
<li><code>X</code>, the matrix or array to summarise</li>
<li><code>MARGIN</code>, an integer vector giving the dimensions to summarise over, 1 = rows, 2 = columns, etc.</li>
<li><code>FUN</code>, a summary function</li>
<li><code>...</code> other arguments passed on to <code>FUN</code></li>
</ul>
<p>A typical example of <code>apply()</code> looks like this</p>
<pre class="sourceCode r"><code class="sourceCode r">a &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span>:<span class="dv">20</span>, <span class="dt">nrow =</span> <span class="dv">5</span>)
<span class="kw">apply</span>(a, <span class="dv">1</span>, mean)
<span class="co">#&gt; [1]  8.5  9.5 10.5 11.5 12.5</span>
<span class="kw">apply</span>(a, <span class="dv">2</span>, mean)
<span class="co">#&gt; [1]  3  8 13 18</span></code></pre>
<p>There are a few caveats to using <code>apply()</code>. It doesn’t have a simplify argument, so you can never be completely sure what type of output you’ll get. This means that <code>apply()</code> is not safe to use inside a function unless you carefully check the inputs. <code>apply()</code> is also not idempotent in the sense that if the summary function is the identity operator, the output is not always the same as the input:</p>
<pre class="sourceCode r"><code class="sourceCode r">a1 &lt;-<span class="st"> </span><span class="kw">apply</span>(a, <span class="dv">1</span>, identity)
<span class="kw">identical</span>(a, a1)
<span class="co">#&gt; [1] FALSE</span>
<span class="kw">identical</span>(a, <span class="kw">t</span>(a1))
<span class="co">#&gt; [1] TRUE</span>
a2 &lt;-<span class="st"> </span><span class="kw">apply</span>(a, <span class="dv">2</span>, identity)
<span class="kw">identical</span>(a, a2)
<span class="co">#&gt; [1] TRUE</span></code></pre>
<p>(You can put high-dimensional arrays back in the right order using <code>aperm()</code>, or use <code>plyr::aaply()</code>, which is idempotent.)</p>
<p><code>sweep()</code> allows you to “sweep” out the values of a summary statistic. It is often used with <code>apply()</code> to standardise arrays. The following example scales the rows of a matrix so that all values lie between 0 and 1. </p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">20</span>, <span class="dv">0</span>, <span class="dv">10</span>), <span class="dt">nrow =</span> <span class="dv">4</span>)
x1 &lt;-<span class="st"> </span><span class="kw">sweep</span>(x, <span class="dv">1</span>, <span class="kw">apply</span>(x, <span class="dv">1</span>, min), <span class="st">`</span><span class="dt">-</span><span class="st">`</span>)
x2 &lt;-<span class="st"> </span><span class="kw">sweep</span>(x1, <span class="dv">1</span>, <span class="kw">apply</span>(x1, <span class="dv">1</span>, max), <span class="st">`</span><span class="dt">/</span><span class="st">`</span>)</code></pre>
<p>The final matrix functional is <code>outer()</code>. It’s a little different in that it takes multiple vector inputs and creates a matrix or array output where the input function is run over every combination of the inputs: </p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Create a times table</span>
<span class="kw">outer</span>(<span class="dv">1</span>:<span class="dv">3</span>, <span class="dv">1</span>:<span class="dv">10</span>, <span class="st">&quot;*&quot;</span>)
<span class="co">#&gt;      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]</span>
<span class="co">#&gt; [1,]    1    2    3    4    5    6    7    8    9    10</span>
<span class="co">#&gt; [2,]    2    4    6    8   10   12   14   16   18    20</span>
<span class="co">#&gt; [3,]    3    6    9   12   15   18   21   24   27    30</span></code></pre>
<p>Good places to learn more about <code>apply()</code> and friends are:</p>
<ul>
<li><p><a href="http://petewerner.blogspot.com/2012/12/using-apply-sapply-lapply-in-r.html">“Using apply, sapply, lapply in R”</a> by Peter Werner.</p></li>
<li><p><a href="http://rforpublichealth.blogspot.no/2012/09/the-infamous-apply-function.html">“The infamous apply function”</a> by Slawa Rokicki.</p></li>
<li><p><a href="http://forgetfulfunctor.blogspot.com/2011/07/r-apply-function-tutorial-with-examples.html">“The R apply function - a tutorial with examples”</a> by axiomOfChoice.</p></li>
<li><p>The stackoverflow question <a href="http://stackoverflow.com/questions/3505701">“R Grouping functions: <code>sapply</code> vs. <code>lapply</code> vs. <code>apply</code> vs. <code>tapply</code> vs. <code>by</code> vs. <code>aggregate</code>”</a>.</p></li>
</ul>
<h3>Group apply</h3>
<p>You can think about <code>tapply()</code> as a generalisation to <code>apply()</code> that allows for “ragged” arrays, arrays where each row can have a different number of columns. This is often needed when you’re trying to summarise a data set. For example, imagine you’ve collected pulse rate data from a medical trial, and you want to compare the two groups: </p>
<pre class="sourceCode r"><code class="sourceCode r">pulse &lt;-<span class="st"> </span><span class="kw">round</span>(<span class="kw">rnorm</span>(<span class="dv">22</span>, <span class="dv">70</span>, <span class="dv">10</span> /<span class="st"> </span><span class="dv">3</span>)) +<span class="st"> </span><span class="kw">rep</span>(<span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">5</span>), <span class="kw">c</span>(<span class="dv">10</span>, <span class="dv">12</span>))
group &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>), <span class="kw">c</span>(<span class="dv">10</span>, <span class="dv">12</span>))

<span class="kw">tapply</span>(pulse, group, length)
<span class="co">#&gt;  A  B </span>
<span class="co">#&gt; 10 12</span>
<span class="kw">tapply</span>(pulse, group, mean)
<span class="co">#&gt;     A     B </span>
<span class="co">#&gt; 71.40 73.25</span></code></pre>
<p><code>tapply()</code> works by creating a “ragged” data structure from a set of inputs, and then applying a function to the individual elements of that structure. The first task is actually what the <code>split()</code> function does. It takes two inputs and returns a list which groups elements together from the first vector according to elements, or categories, from the second vector:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">split</span>(pulse, group)
<span class="co">#&gt; $A</span>
<span class="co">#&gt;  [1] 73 76 68 73 68 69 71 76 72 68</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $B</span>
<span class="co">#&gt;  [1] 75 66 70 73 80 73 72 69 74 74 76 77</span></code></pre>
<p>Then <code>tapply()</code> is just the combination of <code>split()</code> and <code>sapply()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">tapply2 &lt;-<span class="st"> </span>function(x, group, f, ..., <span class="dt">simplify =</span> <span class="ot">TRUE</span>) {
  pieces &lt;-<span class="st"> </span><span class="kw">split</span>(x, group)
  <span class="kw">sapply</span>(pieces, f, <span class="dt">simplify =</span> simplify)
}
<span class="kw">tapply2</span>(pulse, group, length)
<span class="co">#&gt;  A  B </span>
<span class="co">#&gt; 10 12</span>
<span class="kw">tapply2</span>(pulse, group, mean)
<span class="co">#&gt;     A     B </span>
<span class="co">#&gt; 71.40 73.25</span></code></pre>
<p>Being able to rewrite <code>tapply()</code> as a combination of <code>split()</code> and <code>sapply()</code> is a good indication that we’ve identified some useful building blocks. </p>
<h3>The plyr package</h3>
<p>One challenge with using the base functionals is that they have grown organically over time, and have been written by multiple authors. This means that they are not very consistent: </p>
<ul>
<li><p>With <code>tapply()</code> and <code>sapply()</code>, the simplify argument is called <code>simplify</code>. With <code>mapply()</code>, it’s called <code>SIMPLIFY</code>. With <code>apply()</code>, the argument is absent.</p></li>
<li><p><code>vapply()</code> is a variant of <code>sapply()</code> that allows you to describe what the output should be, but there are no corresponding variants for <code>tapply()</code>, <code>apply()</code>, or <code>Map()</code>.</p></li>
<li><p>The first argument of most base functionals is a vector, but the first argument in <code>Map()</code> is a function.</p></li>
</ul>
<p>This makes learning these operators challenging, as you have to memorise all of the variations. Additionally, if you think about the possible combinations of input and output types, base R only covers a partial set of cases:</p>
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="left">list</th>
<th align="left">data frame</th>
<th align="left">array</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">list</td>
<td align="left"><code>lapply()</code></td>
<td align="left"></td>
<td align="left"><code>sapply()</code></td>
</tr>
<tr class="even">
<td align="left">data frame</td>
<td align="left"><code>by()</code></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">array</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><code>apply()</code></td>
</tr>
</tbody>
</table>
<p>This was one of the driving motivations behind the creation of the plyr package. It provides consistently named functions with consistently named arguments and covers all combinations of input and output data structures:</p>
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="left">list</th>
<th align="left">data frame</th>
<th align="left">array</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">list</td>
<td align="left"><code>llply()</code></td>
<td align="left"><code>ldply()</code></td>
<td align="left"><code>laply()</code></td>
</tr>
<tr class="even">
<td align="left">data frame</td>
<td align="left"><code>dlply()</code></td>
<td align="left"><code>ddply()</code></td>
<td align="left"><code>daply()</code></td>
</tr>
<tr class="odd">
<td align="left">array</td>
<td align="left"><code>alply()</code></td>
<td align="left"><code>adply()</code></td>
<td align="left"><code>aaply()</code></td>
</tr>
</tbody>
</table>
<p>Each of these functions splits up the input, applies a function to each piece, and then combines the results. Overall, this process is called “split-apply-combine”. You can read more about it and plyr in <a href="http://www.jstatsoft.org/v40/i01/">“The Split-Apply-Combine Strategy for Data Analysis”</a>, an open-access article published in the <em>Journal of Statistical Software</em>. </p>
<h3>Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>How does <code>apply()</code> arrange the output? Read the documentation and perform some experiments.</p></li>
<li><p>There’s no equivalent to <code>split()</code> + <code>vapply()</code>. Should there be? When would it be useful? Implement one yourself.</p></li>
<li><p>Implement a pure R version of <code>split()</code>. (Hint: use <code>unique()</code> and subsetting.) Can you do it without a for loop?</p></li>
<li><p>What other types of input and output are missing? Brainstorm before you look up some answers in the <a href="http://www.jstatsoft.org/v40/i01/">plyr paper</a>.</p></li>
</ol>
<h2 id="functionals-fp">Manipulating lists</h2>
<p>Another way of thinking about functionals is as a set of general tools for altering, subsetting, and collapsing lists. Every functional programming language has three tools for this: <code>Map()</code>, <code>Reduce()</code>, and <code>Filter()</code>. We’ve seen <code>Map()</code> already, and the following sections describe <code>Reduce()</code>, a powerful tool for extending two-argument functions, and <code>Filter()</code>, a member of an important class of functionals that work with predicates, functions that return a single <code>TRUE</code> or <code>FALSE</code>.</p>
<h3><code>Reduce()</code></h3>
<p><code>Reduce()</code> reduces a vector, <code>x</code>, to a single value by recursively calling a function, <code>f</code>, two arguments at a time. It combines the first two elements with <code>f</code>, then combines the result of that call with the third element, and so on. Calling <code>Reduce(f, 1:3)</code> is equivalent to <code>f(f(1, 2), 3)</code>. Reduce is also known as fold, because it folds together adjacent elements in the list.  </p>
<p>The following two examples show what <code>Reduce</code> does with an infix and prefix function:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Reduce</span>(<span class="st">`</span><span class="dt">+</span><span class="st">`</span>, <span class="dv">1</span>:<span class="dv">3</span>) <span class="co"># -&gt; ((1 + 2) + 3)</span>
<span class="kw">Reduce</span>(sum, <span class="dv">1</span>:<span class="dv">3</span>) <span class="co"># -&gt; sum(sum(1, 2), 3)</span></code></pre>
<p>The essence of <code>Reduce()</code> can be described by a simple for loop:</p>
<pre class="sourceCode r"><code class="sourceCode r">Reduce2 &lt;-<span class="st"> </span>function(f, x) {
  out &lt;-<span class="st"> </span>x[[<span class="dv">1</span>]]
  for(i in <span class="kw">seq</span>(<span class="dv">2</span>, <span class="kw">length</span>(x))) {
    out &lt;-<span class="st"> </span><span class="kw">f</span>(out, x[[i]])
  }
  out
}</code></pre>
<p>The real <code>Reduce()</code> is more complicated because it includes arguments to control whether the values are reduced from the left or from the right (<code>right</code>), an optional initial value (<code>init</code>), and an option to output intermediate results (<code>accumulate</code>).</p>
<p><code>Reduce()</code> is an elegant way of extending a function that works with two inputs into a function that can deal with any number of inputs. It’s useful for implementing many types of recursive operations, like merges and intersections. (We’ll see another use in the final case study.) Imagine you have a list of numeric vectors, and you want to find the values that occur in every element:</p>
<pre class="sourceCode r"><code class="sourceCode r">l &lt;-<span class="st"> </span><span class="kw">replicate</span>(<span class="dv">5</span>, <span class="kw">sample</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="dv">15</span>, <span class="dt">replace =</span> T), <span class="dt">simplify =</span> <span class="ot">FALSE</span>)
<span class="kw">str</span>(l)
<span class="co">#&gt; List of 5</span>
<span class="co">#&gt;  $ : int [1:15] 8 8 5 9 7 7 10 3 3 6 ...</span>
<span class="co">#&gt;  $ : int [1:15] 10 4 9 7 6 7 2 6 7 1 ...</span>
<span class="co">#&gt;  $ : int [1:15] 9 5 8 8 2 8 7 9 5 6 ...</span>
<span class="co">#&gt;  $ : int [1:15] 3 8 5 9 2 7 4 7 3 4 ...</span>
<span class="co">#&gt;  $ : int [1:15] 2 1 4 8 10 2 6 5 4 2 ...</span></code></pre>
<p>You could do that by intersecting each element in turn:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">intersect</span>(<span class="kw">intersect</span>(<span class="kw">intersect</span>(<span class="kw">intersect</span>(l[[<span class="dv">1</span>]], l[[<span class="dv">2</span>]]),
  l[[<span class="dv">3</span>]]), l[[<span class="dv">4</span>]]), l[[<span class="dv">5</span>]])
<span class="co">#&gt; [1] 6</span></code></pre>
<p>That’s hard to read. With <code>Reduce()</code>, the equivalent is:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Reduce</span>(intersect, l)
<span class="co">#&gt; [1] 6</span></code></pre>
<h3>Predicate functionals</h3>
<p>A <strong>predicate</strong> is a function that returns a single <code>TRUE</code> or <code>FALSE</code>, like <code>is.character</code>, <code>all</code>, or <code>is.NULL</code>. A predicate functional applies a predicate to each element of a list or data frame. There are three useful predicate functionals in base R: <code>Filter()</code>, <code>Find()</code>, and <code>Position()</code>.  </p>
<ul>
<li><p><code>Filter()</code> selects only those elements which match the predicate. </p></li>
<li><p><code>Find()</code> returns the first element which matches the predicate (or the last element if <code>right = TRUE</code>). </p></li>
<li><p><code>Position()</code> returns the position of the first element that matches the predicate (or the last element if <code>right = TRUE</code>). </p></li>
</ul>
<p>Another useful predicate functional is <code>where()</code>, a custom functional generates a logical vector from a list (or a data frame) and a predicate: </p>
<pre class="sourceCode r"><code class="sourceCode r">where &lt;-<span class="st"> </span>function(f, x) {
  <span class="kw">vapply</span>(x, f, <span class="kw">logical</span>(<span class="dv">1</span>))
}</code></pre>
<p>The following example shows how you might use these functionals with a data frame:</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span>:<span class="dv">3</span>, <span class="dt">y =</span> <span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>))
<span class="kw">where</span>(is.factor, df)
<span class="co">#&gt;     x     y </span>
<span class="co">#&gt; FALSE  TRUE</span>
<span class="kw">str</span>(<span class="kw">Filter</span>(is.factor, df))
<span class="co">#&gt; &#39;data.frame&#39;:    3 obs. of  1 variable:</span>
<span class="co">#&gt;  $ y: Factor w/ 3 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;: 1 2 3</span>
<span class="kw">str</span>(<span class="kw">Find</span>(is.factor, df))
<span class="co">#&gt;  Factor w/ 3 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;: 1 2 3</span>
<span class="kw">Position</span>(is.factor, df)
<span class="co">#&gt; [1] 2</span></code></pre>
<h3>Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Why isn’t <code>is.na()</code> a predicate function? What base R function is closest to being a predicate version of <code>is.na()</code>?</p></li>
<li><p>Use <code>Filter()</code> and <code>vapply()</code> to create a function that applies a summary statistic to every numeric column in a data frame.</p></li>
<li><p>What’s the relationship between <code>which()</code> and <code>Position()</code>? What’s the relationship between <code>where()</code> and <code>Filter()</code>?</p></li>
<li><p>Implement <code>Any()</code>, a function that takes a list and a predicate function, and returns <code>TRUE</code> if the predicate function returns <code>TRUE</code> for any of the inputs. Implement <code>All()</code> similarly.</p></li>
<li><p>Implement the <code>span()</code> function from Haskell: given a list <code>x</code> and a predicate function <code>f</code>, <code>span</code> returns the location of the longest sequential run of elements where the predicate is true. (Hint: you might find <code>rle()</code> helpful.)</p></li>
</ol>
<h2 id="functionals-math">Mathematical functionals</h2>
<p>Functionals are very common in mathematics. The limit, the maximum, the roots (the set of points where <code>f(x) = 0</code>), and the definite integral are all functionals: given a function, they return a single number (or vector of numbers). At first glance, these functions don’t seem to fit in with the theme of eliminating loops, but if you dig deeper you’ll find out that they are all implemented using an algorithm that involves iteration.</p>
<p>In this section we’ll use some of R’s built-in mathematical functionals. There are three functionals that work with functions to return single numeric values:   </p>
<ul>
<li><code>integrate()</code> finds the area under the curve defined by <code>f()</code></li>
<li><code>uniroot()</code> finds where <code>f()</code> hits zero</li>
<li><code>optimise()</code> finds the location of lowest (or highest) value of <code>f()</code></li>
</ul>
<p>Let’s explore how these are used with a simple function, <code>sin()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">integrate</span>(sin, <span class="dv">0</span>, pi)
<span class="co">#&gt; 2 with absolute error &lt; 2.2e-14</span>
<span class="kw">str</span>(<span class="kw">uniroot</span>(sin, pi *<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span> /<span class="st"> </span><span class="dv">2</span>, <span class="dv">3</span> /<span class="st"> </span><span class="dv">2</span>)))
<span class="co">#&gt; List of 5</span>
<span class="co">#&gt;  $ root      : num 3.14</span>
<span class="co">#&gt;  $ f.root    : num 1.22e-16</span>
<span class="co">#&gt;  $ iter      : int 2</span>
<span class="co">#&gt;  $ init.it   : int NA</span>
<span class="co">#&gt;  $ estim.prec: num 6.1e-05</span>
<span class="kw">str</span>(<span class="kw">optimise</span>(sin, <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">2</span> *<span class="st"> </span>pi)))
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ minimum  : num 4.71</span>
<span class="co">#&gt;  $ objective: num -1</span>
<span class="kw">str</span>(<span class="kw">optimise</span>(sin, <span class="kw">c</span>(<span class="dv">0</span>, pi), <span class="dt">maximum =</span> <span class="ot">TRUE</span>))
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ maximum  : num 1.57</span>
<span class="co">#&gt;  $ objective: num 1</span></code></pre>
<p>In statistics, optimisation is often used for maximum likelihood estimation (MLE). In MLE, we have two sets of parameters: the data, which is fixed for a given problem, and the parameters, which vary as we try to find the maximum. These two sets of parameters make the problem well suited for closures. Combining closures with optimisation gives rise to the following approach to solving MLE problems. </p>
<p>The following example shows how we might find the maximum likelihood estimate for <span class="math"><em>λ</em></span>, if our data come from a Poisson distribution. First, we create a function factory that, given a dataset, returns a function that computes the negative log likelihood (NLL) for parameter <code>lambda</code>. In R, it’s common to work with the negative since <code>optimise()</code> defaults to finding the minimum. </p>
<pre class="sourceCode r"><code class="sourceCode r">poisson_nll &lt;-<span class="st"> </span>function(x) {
  n &lt;-<span class="st"> </span><span class="kw">length</span>(x)
  sum_x &lt;-<span class="st"> </span><span class="kw">sum</span>(x)
  function(lambda) {
    n *<span class="st"> </span>lambda -<span class="st"> </span>sum_x *<span class="st"> </span><span class="kw">log</span>(lambda) <span class="co"># + terms not involving lambda</span>
  }
}</code></pre>
<p>Note how the closure allows us to precompute values that are constant with respect to the data.</p>
<p>We can use this function factory to generate specific NLL functions for input data. Then <code>optimise()</code> allows us to find the best values (the maximum likelihood estimates), given a generous starting range.</p>
<pre class="sourceCode r"><code class="sourceCode r">x1 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">41</span>, <span class="dv">30</span>, <span class="dv">31</span>, <span class="dv">38</span>, <span class="dv">29</span>, <span class="dv">24</span>, <span class="dv">30</span>, <span class="dv">29</span>, <span class="dv">31</span>, <span class="dv">38</span>)
x2 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">6</span>, <span class="dv">4</span>, <span class="dv">7</span>, <span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">7</span>, <span class="dv">5</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">7</span>, <span class="dv">5</span>, <span class="dv">4</span>, <span class="dv">12</span>, <span class="dv">6</span>, <span class="dv">9</span>)
nll1 &lt;-<span class="st"> </span><span class="kw">poisson_nll</span>(x1)
nll2 &lt;-<span class="st"> </span><span class="kw">poisson_nll</span>(x2)

<span class="kw">optimise</span>(nll1, <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">100</span>))$minimum
<span class="co">#&gt; [1] 32.09999</span>
<span class="kw">optimise</span>(nll2, <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">100</span>))$minimum
<span class="co">#&gt; [1] 5.466681</span></code></pre>
<p>We can check that these values are correct by comparing them to the analytic solution: in this case, it’s just the mean of the data, 32.1 and 5.4666667.</p>
<p>Another important mathematical functional is <code>optim()</code>. It is a generalisation of <code>optimise()</code> that works with more than one dimension. If you’re interested in how it works, you might want to explore the <code>Rvmmin</code> package, which provides a pure-R implementation of <code>optim()</code>. Interestingly <code>Rvmmin</code> is no slower than <code>optim()</code>, even though it is written in R, not C. For this problem, the bottleneck lies not in controlling the optimisation but with having to evaluate the function multiple times. </p>
<h3>Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Implement <code>arg_max()</code>. It should take a function and a vector of inputs, and return the elements of the input where the function returns the highest value. For example, <code>arg_max(-10:5, function(x) x ^ 2)</code> should return -10. <code>arg_max(-5:5, function(x) x ^ 2)</code> should return <code>c(-5, 5)</code>. Also implement the matching <code>arg_min()</code> function.</p></li>
<li><p>Challenge: read about the <a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-12.html#%_sec_1.3">fixed point algorithm</a>. Complete the exercises using R.</p></li>
</ol>
<h2 id="functionals-not">Loops that should be left as is</h2>
<p>Some loops have no natural functional equivalent. In this section you’ll learn about three common cases: </p>
<ul>
<li>modifying in place</li>
<li>recursive functions</li>
<li>while loops</li>
</ul>
<p>It’s possible to torture these problems to use a functional, but it’s not a good idea. You’ll create code that is harder to understand, eliminating the main reason for using functionals in the first case.</p>
<h3>Modifying in place</h3>
<p>If you need to modify part of an existing data frame, it’s often better to use a for loop. For example, the following code performs a variable-by-variable transformation by matching the names of a list of functions to the names of variables in a data frame.</p>
<pre class="sourceCode r"><code class="sourceCode r">trans &lt;-<span class="st"> </span><span class="kw">list</span>(
  <span class="dt">disp =</span> function(x) x *<span class="st"> </span><span class="fl">0.0163871</span>,
  <span class="dt">am =</span> function(x) <span class="kw">factor</span>(x, <span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">&quot;auto&quot;</span>, <span class="st">&quot;manual&quot;</span>))
)
for(var in <span class="kw">names</span>(trans)) {
  mtcars[[var]] &lt;-<span class="st"> </span>trans[[var]](mtcars[[var]])
}</code></pre>
<p>We wouldn’t normally use <code>lapply()</code> to replace this loop directly, but it is <em>possible</em>. Just replace the loop with <code>lapply()</code> by using <code>&lt;&lt;-</code>: </p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">lapply</span>(<span class="kw">names</span>(trans), function(var) {
  mtcars[[var]] &lt;&lt;-<span class="st"> </span>trans[[var]](mtcars[[var]])
})</code></pre>
<p>The for loop is gone, but the code is longer and much harder to understand. The reader needs to understand <code>&lt;&lt;-</code> and how <code>x[[y]] &lt;&lt;- z</code> works (it’s not simple!). In short, we’ve taken a simple, easily understood for loop, and turned it into something few people will understand: not a good idea!</p>
<h3>Recursive relationships</h3>
<p>It’s hard to convert a for loop into a functional when the relationship between elements is not independent, or is defined recursively. For example, exponential smoothing works by taking a weighted average of the current and previous data points. The <code>exps()</code> function below implements exponential smoothing with a for loop. </p>
<pre class="sourceCode r"><code class="sourceCode r">exps &lt;-<span class="st"> </span>function(x, alpha) {
  s &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="kw">length</span>(x) +<span class="st"> </span><span class="dv">1</span>)
  for (i in <span class="kw">seq_along</span>(s)) {
    if (i ==<span class="st"> </span><span class="dv">1</span>) {
      s[i] &lt;-<span class="st"> </span>x[i]
    } else {
      s[i] &lt;-<span class="st"> </span>alpha *<span class="st"> </span>x[i -<span class="st"> </span><span class="dv">1</span>] +<span class="st"> </span>(<span class="dv">1</span> -<span class="st"> </span>alpha) *<span class="st"> </span>s[i -<span class="st"> </span><span class="dv">1</span>]
    }
  }
  s
}
x &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="dv">6</span>)
<span class="kw">exps</span>(x, <span class="fl">0.5</span>)
<span class="co">#&gt; [1] 0.2340385 0.2340385 0.4690412 0.3090201 0.2545220 0.1794157 0.1261481</span></code></pre>
<p>We can’t eliminate the for loop because none of the functionals we’ve seen allow the output at position <code>i</code> to depend on both the input and output at position <code>i - 1</code>.</p>
<p>One way to eliminate the for loop in this case is to <a href="http://en.wikipedia.org/wiki/Recurrence_relation#Solving">solve the recurrence relation</a> by removing the recursion and replacing it with explicit references. This requires a new set of mathematical tools, and is challenging, but it can pay off by producing a simpler function.</p>
<h3>While loops</h3>
<p>Another type of looping construct in R is the <code>while</code> loop. It keeps running until some condition is met. <code>while</code> loops are more general than <code>for</code> loops: you can rewrite every for loop as a while loop, but you can’t do the reverse. For example, we could turn this for loop:  </p>
<pre class="sourceCode r"><code class="sourceCode r">for (i in <span class="dv">1</span>:<span class="dv">10</span>) <span class="kw">print</span>(i)</code></pre>
<p>into this while loop:</p>
<pre class="sourceCode r"><code class="sourceCode r">i &lt;-<span class="st"> </span><span class="dv">1</span>
while(i &lt;=<span class="st"> </span><span class="dv">10</span>) {
  <span class="kw">print</span>(i)
  i &lt;-<span class="st"> </span>i +<span class="st"> </span><span class="dv">1</span>
}</code></pre>
<p>Not every while loop can be turned into a for loop because many while loops don’t know in advance how many times they will be run:</p>
<pre class="sourceCode r"><code class="sourceCode r">i &lt;-<span class="st"> </span><span class="dv">0</span>
while(<span class="ot">TRUE</span>) {
  if (<span class="kw">runif</span>(<span class="dv">1</span>) &gt;<span class="st"> </span><span class="fl">0.9</span>) break
  i &lt;-<span class="st"> </span>i +<span class="st"> </span><span class="dv">1</span>
}</code></pre>
<p>This is a common problem when you’re writing simulations.</p>
<p>In this case we can remove the loop by recognising a special feature of the problem. Here we’re counting the number of successes before Bernoulli trial with p = 0.1 fails. This is a geometric random variable, so you could replace the code with <code>i &lt;- rgeom(1, 0.1)</code>. Reformulating the problem in this way is hard to do in general, but you’ll benefit greatly if you can do it for your problem.</p>
<h2 id="function-family">A family of functions</h2>
<p>To finish off the chapter, this case study shows how you can use functionals to take a simple building block and make it powerful and general. I’ll start with a simple idea, adding two numbers together, and use functionals to extend it to summing multiple numbers, computing parallel and cumulative sums, and summing across array dimensions.</p>
<p>We’ll start by defining a very simple addition function, one which takes two scalar arguments:</p>
<pre class="sourceCode r"><code class="sourceCode r">add &lt;-<span class="st"> </span>function(x, y) {
  <span class="kw">stopifnot</span>(<span class="kw">length</span>(x) ==<span class="st"> </span><span class="dv">1</span>, <span class="kw">length</span>(y) ==<span class="st"> </span><span class="dv">1</span>,
    <span class="kw">is.numeric</span>(x), <span class="kw">is.numeric</span>(y))
  x +<span class="st"> </span>y
}</code></pre>
<p>(We’re using R’s existing addition operator here, which does much more, but the focus here is on how we can take very simple building blocks and extend them to do more.)</p>
<p>I’ll also add an <code>na.rm</code> argument. A helper function will make this a bit easier: if <code>x</code> is missing it should return <code>y</code>, if <code>y</code> is missing it should return <code>x</code>, and if both <code>x</code> and <code>y</code> are missing then it should return another argument to the function: <code>identity</code>. This function is probably a bit more general than what we need now, but it’s useful if we implement other binary operators.</p>
<pre class="sourceCode r"><code class="sourceCode r">rm_na &lt;-<span class="st"> </span>function(x, y, identity) {
  if (<span class="kw">is.na</span>(x) &amp;&amp;<span class="st"> </span><span class="kw">is.na</span>(y)) {
    identity
  } else if (<span class="kw">is.na</span>(x)) {
    y
  } else {
    x
  }
}
<span class="kw">rm_na</span>(<span class="ot">NA</span>, <span class="dv">10</span>, <span class="dv">0</span>)
<span class="co">#&gt; [1] 10</span>
<span class="kw">rm_na</span>(<span class="dv">10</span>, <span class="ot">NA</span>, <span class="dv">0</span>)
<span class="co">#&gt; [1] 10</span>
<span class="kw">rm_na</span>(<span class="ot">NA</span>, <span class="ot">NA</span>, <span class="dv">0</span>)
<span class="co">#&gt; [1] 0</span></code></pre>
<p>This allows us to write a version of <code>add()</code> that can deal with missing values if needed:</p>
<pre class="sourceCode r"><code class="sourceCode r">add &lt;-<span class="st"> </span>function(x, y, <span class="dt">na.rm =</span> <span class="ot">FALSE</span>) {
  if (na.rm &amp;&amp;<span class="st"> </span>(<span class="kw">is.na</span>(x) ||<span class="st"> </span><span class="kw">is.na</span>(y))) <span class="kw">rm_na</span>(x, y, <span class="dv">0</span>) else x +<span class="st"> </span>y
}
<span class="kw">add</span>(<span class="dv">10</span>, <span class="ot">NA</span>)
<span class="co">#&gt; [1] NA</span>
<span class="kw">add</span>(<span class="dv">10</span>, <span class="ot">NA</span>, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; [1] 10</span>
<span class="kw">add</span>(<span class="ot">NA</span>, <span class="ot">NA</span>)
<span class="co">#&gt; [1] NA</span>
<span class="kw">add</span>(<span class="ot">NA</span>, <span class="ot">NA</span>, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; [1] 0</span></code></pre>
<p>Why did we pick an identity of <code>0</code>? Why should <code>add(NA, NA, na.rm = TRUE)</code> return 0? Well, for every other input it returns a number, so even if both arguments are <code>NA</code>, it should still do that. What number should it return? We can figure it out because additional is associative, which means that the order of additional doesn’t matter. That means that the following two function calls should return the same value:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">add</span>(<span class="kw">add</span>(<span class="dv">3</span>, <span class="ot">NA</span>, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>), <span class="ot">NA</span>, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; [1] 3</span>
<span class="kw">add</span>(<span class="dv">3</span>, <span class="kw">add</span>(<span class="ot">NA</span>, <span class="ot">NA</span>, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>), <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; [1] 3</span></code></pre>
<p>This implies that <code>add(NA, NA, na.rm = TRUE)</code> must be 0, and hence <code>identity = 0</code> is the correct default.</p>
<p>Now that we have the basics working, we can extend the function to deal with more complicated inputs. One obvious generalisation is to add more than two numbers. We can do this by iteratively adding two numbers: if the input is <code>c(1, 2, 3)</code> we compute <code>add(add(1, 2), 3)</code>. This is a simple application of <code>Reduce()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">r_add &lt;-<span class="st"> </span>function(xs, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>) {
  <span class="kw">Reduce</span>(function(x, y) <span class="kw">add</span>(x, y, <span class="dt">na.rm =</span> na.rm), xs)
}
<span class="kw">r_add</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">10</span>))
<span class="co">#&gt; [1] 15</span></code></pre>
<p>This looks good, but we need to test a few special cases:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">r_add</span>(<span class="ot">NA</span>, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; [1] NA</span>
<span class="kw">r_add</span>(<span class="kw">numeric</span>())
<span class="co">#&gt; NULL</span></code></pre>
<p>These are incorrect. In the first case, we get a missing value even though we’ve explicitly asked to ignore them. In the second case, we get <code>NULL</code> instead of a length one numeric vector (as we do for every other set of inputs).</p>
<p>The two problems are related. If we give <code>Reduce()</code> a length one vector, it doesn’t have anything to reduce, so it just returns the input. If we give it an input of length zero, it always returns <code>NULL</code>. The easiest way to fix this problem is to use the <code>init</code> argument of <code>Reduce()</code>. This is added to the start of every input vector:</p>
<pre class="sourceCode r"><code class="sourceCode r">r_add &lt;-<span class="st"> </span>function(xs, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>) {
  <span class="kw">Reduce</span>(function(x, y) <span class="kw">add</span>(x, y, <span class="dt">na.rm =</span> na.rm), xs, <span class="dt">init =</span> <span class="dv">0</span>)
}
<span class="kw">r_add</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">10</span>))
<span class="co">#&gt; [1] 15</span>
<span class="kw">r_add</span>(<span class="ot">NA</span>, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; [1] 0</span>
<span class="kw">r_add</span>(<span class="kw">numeric</span>())
<span class="co">#&gt; [1] 0</span></code></pre>
<p><code>r_add()</code> is equivalent to <code>sum()</code>.</p>
<p>It would be nice to have a vectorised version of <code>add()</code> so that we can perform the addition of two vectors of numbers in element-wise fashion. We could use <code>Map()</code> or <code>vapply()</code> to implement this, but neither is perfect. <code>Map()</code> returns a list, instead of a numeric vector, so we need to use <code>simplify2array()</code>. <code>vapply()</code> returns a vector but it requires us to loop over a set of indices.</p>
<pre class="sourceCode r"><code class="sourceCode r">v_add1 &lt;-<span class="st"> </span>function(x, y, <span class="dt">na.rm =</span> <span class="ot">FALSE</span>) {
  <span class="kw">stopifnot</span>(<span class="kw">length</span>(x) ==<span class="st"> </span><span class="kw">length</span>(y), <span class="kw">is.numeric</span>(x), <span class="kw">is.numeric</span>(y))
  if (<span class="kw">length</span>(x) ==<span class="st"> </span><span class="dv">0</span>) <span class="kw">return</span>(<span class="kw">numeric</span>())
  <span class="kw">simplify2array</span>(
    <span class="kw">Map</span>(function(x, y) <span class="kw">add</span>(x, y, <span class="dt">na.rm =</span> na.rm), x, y)
  )
}

v_add2 &lt;-<span class="st"> </span>function(x, y, <span class="dt">na.rm =</span> <span class="ot">FALSE</span>) {
  <span class="kw">stopifnot</span>(<span class="kw">length</span>(x) ==<span class="st"> </span><span class="kw">length</span>(y), <span class="kw">is.numeric</span>(x), <span class="kw">is.numeric</span>(y))
  <span class="kw">vapply</span>(<span class="kw">seq_along</span>(x), function(i) <span class="kw">add</span>(x[i], y[i], <span class="dt">na.rm =</span> na.rm),
    <span class="kw">numeric</span>(<span class="dv">1</span>))
}</code></pre>
<p>A few test cases help to ensure that it behaves as we expect. We’re a bit stricter than base R here because we don’t do recycling. (You could add that if you wanted, but I find that recycling is a frequent source of silent bugs.)</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Both versions give the same results</span>
<span class="kw">v_add1</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="dv">1</span>:<span class="dv">10</span>)
<span class="co">#&gt;  [1]  2  4  6  8 10 12 14 16 18 20</span>
<span class="kw">v_add1</span>(<span class="kw">numeric</span>(), <span class="kw">numeric</span>())
<span class="co">#&gt; numeric(0)</span>
<span class="kw">v_add1</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="ot">NA</span>), <span class="kw">c</span>(<span class="dv">1</span>, <span class="ot">NA</span>))
<span class="co">#&gt; [1]  2 NA</span>
<span class="kw">v_add1</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="ot">NA</span>), <span class="kw">c</span>(<span class="dv">1</span>, <span class="ot">NA</span>), <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; [1] 2 0</span></code></pre>
<p>Another variant of <code>add()</code> is the cumulative sum. We can implement it with <code>Reduce()</code> by setting the <code>accumulate</code> argument to <code>TRUE</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">c_add &lt;-<span class="st"> </span>function(xs, <span class="dt">na.rm =</span> <span class="ot">FALSE</span>) {
  <span class="kw">Reduce</span>(function(x, y) <span class="kw">add</span>(x, y, <span class="dt">na.rm =</span> na.rm), xs,
    <span class="dt">accumulate =</span> <span class="ot">TRUE</span>)
}
<span class="kw">c_add</span>(<span class="dv">1</span>:<span class="dv">10</span>)
<span class="co">#&gt;  [1]  1  3  6 10 15 21 28 36 45 55</span>
<span class="kw">c_add</span>(<span class="dv">10</span>:<span class="dv">1</span>)
<span class="co">#&gt;  [1] 10 19 27 34 40 45 49 52 54 55</span></code></pre>
<p>This is equivalent to <code>cumsum()</code>.</p>
<p>Finally, we might want to define addition for more complicated data structures like matrices. We could create <code>row</code> and <code>col</code> variants that sum across rows and columns, respectively, or we could go the whole hog and define an array version that could sum across any arbitrary set of dimensions. These are easily implemented as combinations of <code>add()</code> and <code>apply()</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">row_sum &lt;-<span class="st"> </span>function(x, <span class="dt">na.rm =</span> <span class="ot">FALSE</span>) {
  <span class="kw">apply</span>(x, <span class="dv">1</span>, add, <span class="dt">na.rm =</span> na.rm)
}
col_sum &lt;-<span class="st"> </span>function(x, <span class="dt">na.rm =</span> <span class="ot">FALSE</span>) {
  <span class="kw">apply</span>(x, <span class="dv">2</span>, add, <span class="dt">na.rm =</span> na.rm)
}
arr_sum &lt;-<span class="st"> </span>function(x, dim, <span class="dt">na.rm =</span> <span class="ot">FALSE</span>) {
  <span class="kw">apply</span>(x, dim, add, <span class="dt">na.rm =</span> na.rm)
}</code></pre>
<p>The first two are equivalent to <code>rowSums()</code> and <code>colSums()</code>.</p>
<p>If every function we have created has an existing equivalent in base R, why did we bother? There are two main reasons:</p>
<ul>
<li><p>Since all variants were implemented by combining a simple binary operator (<code>add()</code>) and a well-tested functional (<code>Reduce()</code>, <code>Map()</code>, <code>apply()</code>), we know that our variants will behave consistently.</p></li>
<li><p>We can apply the same infrastructure to other operators, especially those that might not have the full suite of variants in base R.</p></li>
</ul>
<p>The downside of this approach is that these implementations are not that efficient. (For example, <code>colSums(x)</code> is much faster than <code>apply(x, 2, sum)</code>.) However, even if they aren’t that fast, simple implementations are still a good starting point because they’re less likely to have bugs. When you create faster versions, you can compare the results to make sure your fast versions are still correct.</p>
<p>If you enjoyed this section, you might also enjoy <a href="http://stevelosh.com/blog/2013/03/list-out-of-lambda/">“List out of lambda”</a>, a blog article by Steve Losh that shows how you can produce high level language structures (like lists) out of more primitive language features (like closures, aka lambdas).</p>
<h3>Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Implement <code>smaller</code> and <code>larger</code> functions that, given two inputs, return either the smaller or the larger value. Implement <code>na.rm = TRUE</code>: what should the identity be? (Hint: <code>smaller(x, smaller(NA, NA, na.rm = TRUE), na.rm = TRUE)</code> must be <code>x</code>, so <code>smaller(NA, NA, na.rm = TRUE)</code> must be bigger than any other value of x.) Use <code>smaller</code> and <code>larger</code> to implement equivalents of <code>min()</code>, <code>max()</code>, <code>pmin()</code>, <code>pmax()</code>, and new functions <code>row_min()</code> and <code>row_max()</code>.</p></li>
<li><p>Create a table that has <em>and</em>, <em>or</em>, <em>add</em>, <em>multiply</em>, <em>smaller</em>, and <em>larger</em> in the columns and <em>binary operator</em>, <em>reducing variant</em>, <em>vectorised variant</em>, and <em>array variants</em> in the rows.</p>
<ol style="list-style-type: lower-alpha">
<li><p>Fill in the cells with the names of base R functions that perform each of the roles.</p></li>
<li><p>Compare the names and arguments of the existing R functions. How consistent are they? How could you improve them?</p></li>
<li><p>Complete the matrix by implementing any missing functions.</p></li>
</ol></li>
<li><p>How does <code>paste()</code> fit into this structure? What is the scalar binary function that underlies <code>paste()</code>? What are the <code>sep</code> and <code>collapse</code> arguments to <code>paste()</code> equivalent to? Are there any <code>paste</code> variants that don’t have existing R implementations?</p></li>
</ol>

        </div>
      </div>

      <div class="footer">
        <hr>
        <p>&copy; Hadley Wickham. Powered by <a href="http://jekyllrb.com/">jekyll</a>,
          <a href="http://yihui.name/knitr/">knitr</a>, and
          <a href="http://johnmacfarlane.net/pandoc/">pandoc</a>. Source
          available on <a href="https://github.com/hadley/adv-r/">github</a>.
        </p>
      </div>

    </div> <!-- /container -->

  <script src="//code.jquery.com/jquery.js"></script>
  <script src="www/bootstrap.min.js"></script>
  <script src="www/toc.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-67989-16', 'had.co.nz');
    ga('send', 'pageview');

  </script>
  </body>
</html>
