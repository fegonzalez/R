<!DOCTYPE html>
<html>
  <head>
    <title>Subsetting &middot; Advanced R.</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="www/bootstrap.min.css" rel="stylesheet">
    <link href="www/highlight.css" rel="stylesheet">

    <link href='http://fonts.googleapis.com/css?family=Inconsolata:400,700'
      rel='stylesheet' type='text/css'>
  </head>

  <body>

    <div class="container">

      <div class="masthead">
        <ul class="nav nav-pills pull-right">
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">
              Table of contents<b class="caret"></b>
            </a>
            <ul class="dropdown-menu pull-right" role="menu">
              <li><a href="Introduction.html">Introduction</a></li>
<li class="dropdown-header">Foundations</li>
<li><a href="Data-structures.html">Data structures</a></li>
<li><a href="Subsetting.html">Subsetting</a></li>
<li><a href="Vocabulary.html">Vocabulary</a></li>
<li><a href="Style.html">Style</a></li>
<li><a href="Functions.html">Functions</a></li>
<li><a href="OO-essentials.html">OO field guide</a></li>
<li><a href="Environments.html">Environments</a></li>
<li><a href="Exceptions-Debugging.html">Exceptions and debugging</a></li>

<li class="dropdown-header">Functional programming</li>
<li><a href="Functional-programming.html">Functional programming</a></li>
<li><a href="Functionals.html">Functionals</a></li>
<li><a href="Function-operators.html">Function operators</a></li>

<li class="dropdown-header">Metaprogramming</li>
<li><a href="Computing-on-the-language.html">Non-standard evaluation</a></li>
<li><a href="Expressions.html">Expressions</a></li>
<li><a href="dsl.html">Domain specific languages</a></li>

<li class="dropdown-header">Performant code</li>
<li><a href="Performance.html">Performance</a></li>
<li><a href="Profiling.html">Profiling</a></li>
<li><a href="memory.html">Memory</a></li>
<li><a href="Rcpp.html">Rcpp</a></li>
<li><a href="C-interface.html">R's C interface</a></li>

            </ul>
          </li>
        </ul>

        <h3 class="muted"><a href="/">Advanced R</a> <small>by Hadley Wickham</small></h3>
        <hr>
      </div>

      <div class="row">
        <div class="col-xs-12 col-sm-3" id="nav">
        <div class="well">
          Want to learn from me in person? I'm next teaching in <a href="https://rstudio-chicago.eventbrite.com">Chicago, May 27-28</a>.
        </div>

        <div class="well">
          Want a physical copy of this material? <a href="http://amzn.com/1466586966?tag=devtools-20">Buy a book from amazon!</a>.
        </div>

        <h4>Contents</h4>
          <ul class="list-unstyled" id="toc"></ul>

          <hr>
          <p><a href="/contribute.html">How to contribute</a></p>

          <p><a class="btn btn-primary" href="https://github.com/hadley/adv-r/edit/master/Subsetting.rmd">Edit this page</a></p>
        </div>

        <div id="content" class="col-xs-12 col-sm-8 pull-right">
          <h1 id="subsetting">Subsetting</h1>
<p>R’s subsetting operators are powerful and fast. Mastery of subsetting allows you to succinctly express complex operations in a way that few other languages can match. Subsetting is hard to learn because you need to master a number of interrelated concepts:</p>
<ul>
<li><p>The three subsetting operators.</p></li>
<li><p>The six types of subsetting.</p></li>
<li><p>Important differences in behaviour for different objects (e.g., vectors, lists, factors, matrices, and data frames).</p></li>
<li><p>The use of subsetting in conjunction with assignment.</p></li>
</ul>
<p>This chapter helps you master subsetting by starting with the simplest type of subsetting: subsetting an atomic vector with <code>[</code>. It then gradually extends your knowledge, first to more complicated data types (like arrays and lists), and then to the other subsetting operators, <code>[[</code> and <code>$</code>. You’ll then learn how subsetting and assignment can be combined to modify parts of an object, and, finally, you’ll see a large number of useful applications.</p>
<p>Subsetting is a natural complement to <code>str()</code>. <code>str()</code> shows you the structure of any object, and subsetting allows you to pull out the pieces that you’re interested in. </p>
<h5>Quiz</h5>
<p>Take this short quiz to determine if you need to read this chapter. If the answers quickly come to mind, you can comfortably skip this chapter. Check your answers in <a href="Subsetting.html#subsetting-answers">answers</a>.</p>
<ol style="list-style-type: decimal">
<li><p>What is the result of subsetting a vector with positive integers, negative integers, a logical vector, or a character vector?</p></li>
<li><p>What’s the difference between <code>[</code>, <code>[[</code>, and <code>$</code> when applied to a list?</p></li>
<li><p>When should you use <code>drop = FALSE</code>?</p></li>
<li><p>If <code>x</code> is a matrix, what does <code>x[] &lt;- 0</code> do? How is it different to <code>x &lt;- 0</code>?</p></li>
<li><p>How can you use a named vector to relabel categorical variables?</p></li>
</ol>
<h5>Outline</h5>
<ul>
<li><p><a href="Subsetting.html#data-types">Data types</a> starts by teaching you about <code>[</code>. You’ll start by learning the six types of data that you can use to subset atomic vectors. You’ll then learn how those six data types act when used to subset lists, matrices, data frames, and S3 objects.</p></li>
<li><p><a href="Subsetting.html#subsetting-operators">Subsetting operators</a> expands your knowledge of subsetting operators to include <code>[[</code> and <code>$</code>, focussing on the important principles of simplifying vs. preserving.</p></li>
<li><p>In <a href="Subsetting.html#subassignment">Subsetting and assignment</a> you’ll learn the art of subassignment, combining subsetting and assignment to modify parts of an object.</p></li>
<li><p><a href="Subsetting.html#applications">Applications</a> leads you through eight important, but not obvious, applications of subsetting to solve problems that you often encounter in a data analysis.</p></li>
</ul>
<h2 id="data-types">Data types</h2>
<p>It’s easiest to learn how subsetting works for atomic vectors, and then how it generalises to higher dimensions and other more complicated objects. We’ll start with <code>[</code>, the most commonly used operator. <a href="Subsetting.html#subsetting-operators">Subsetting operators</a> will cover <code>[[</code> and <code>$</code>, the two other main subsetting operators.</p>
<h3>Atomic vectors</h3>
<p>Let’s explore the different types of subsetting with a simple vector, <code>x</code>.   </p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">2.1</span>, <span class="fl">4.2</span>, <span class="fl">3.3</span>, <span class="fl">5.4</span>)</code></pre>
<p>Note that the number after the decimal point gives the original position in the vector.</p>
<p>There are five things that you can use to subset a vector:</p>
<ul>
<li><p><strong>Positive integers</strong> return elements at the specified positions: </p>
<pre class="sourceCode r"><code class="sourceCode r">x[<span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">1</span>)]
<span class="co">#&gt; [1] 3.3 2.1</span>
x[<span class="kw">order</span>(x)]
<span class="co">#&gt; [1] 2.1 3.3 4.2 5.4</span>

<span class="co"># Duplicated indices yield duplicated values</span>
x[<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>)]
<span class="co">#&gt; [1] 2.1 2.1</span>

<span class="co"># Real numbers are silently truncated to integers</span>
x[<span class="kw">c</span>(<span class="fl">2.1</span>, <span class="fl">2.9</span>)]
<span class="co">#&gt; [1] 4.2 4.2</span></code></pre></li>
<li><p><strong>Negative integers</strong> omit elements at the specified positions: </p>
<pre class="sourceCode r"><code class="sourceCode r">x[-<span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">1</span>)]
<span class="co">#&gt; [1] 4.2 5.4</span></code></pre>
<p>You can’t mix positive and negative integers in a single subset:</p>
<pre class="sourceCode r"><code class="sourceCode r">x[<span class="kw">c</span>(-<span class="dv">1</span>, <span class="dv">2</span>)]
<span class="co">#&gt; Error in x[c(-1, 2)]: only 0&#39;s may be mixed with negative subscripts</span></code></pre></li>
<li><p><strong>Logical vectors</strong> select elements where the corresponding logical value is <code>TRUE</code>. This is probably the most useful type of subsetting because you write the expression that creates the logical vector: </p>
<pre class="sourceCode r"><code class="sourceCode r">x[<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">FALSE</span>)]
<span class="co">#&gt; [1] 2.1 4.2</span>
x[x &gt;<span class="st"> </span><span class="dv">3</span>]
<span class="co">#&gt; [1] 4.2 3.3 5.4</span></code></pre>
<p>If the logical vector is shorter than the vector being subsetted, it will be <em>recycled</em> to be the same length.</p>
<pre class="sourceCode r"><code class="sourceCode r">x[<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>)]
<span class="co">#&gt; [1] 2.1 3.3</span>
<span class="co"># Equivalent to</span>
x[<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">TRUE</span>, <span class="ot">FALSE</span>)]
<span class="co">#&gt; [1] 2.1 3.3</span></code></pre>
<p>A missing value in the index always yields a missing value in the output:</p>
<pre class="sourceCode r"><code class="sourceCode r">x[<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">TRUE</span>, <span class="ot">NA</span>, <span class="ot">FALSE</span>)]
<span class="co">#&gt; [1] 2.1 4.2  NA</span></code></pre></li>
<li><p><strong>Nothing</strong> returns the original vector. This is not useful for vectors but is very useful for matrices, data frames, and arrays. It can also be useful in conjunction with assignment.</p>
<pre class="sourceCode r"><code class="sourceCode r">x[]
<span class="co">#&gt; [1] 2.1 4.2 3.3 5.4</span></code></pre></li>
<li><p><strong>Zero</strong> returns a zero-length vector. This is not something you usually do on purpose, but it can be helpful for generating test data.</p>
<pre class="sourceCode r"><code class="sourceCode r">x[<span class="dv">0</span>]
<span class="co">#&gt; numeric(0)</span></code></pre></li>
</ul>
<p>If the vector is named, you can also use:</p>
<ul>
<li><p><strong>Character vectors</strong> to return elements with matching names. </p>
<pre class="sourceCode r"><code class="sourceCode r">(y &lt;-<span class="st"> </span><span class="kw">setNames</span>(x, letters[<span class="dv">1</span>:<span class="dv">4</span>]))
<span class="co">#&gt;   a   b   c   d </span>
<span class="co">#&gt; 2.1 4.2 3.3 5.4</span>
y[<span class="kw">c</span>(<span class="st">&quot;d&quot;</span>, <span class="st">&quot;c&quot;</span>, <span class="st">&quot;a&quot;</span>)]
<span class="co">#&gt;   d   c   a </span>
<span class="co">#&gt; 5.4 3.3 2.1</span>

<span class="co"># Like integer indices, you can repeat indices</span>
y[<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;a&quot;</span>, <span class="st">&quot;a&quot;</span>)]
<span class="co">#&gt;   a   a   a </span>
<span class="co">#&gt; 2.1 2.1 2.1</span>

<span class="co"># When subsetting with [ names are always matched exactly</span>
z &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dt">abc =</span> <span class="dv">1</span>, <span class="dt">def =</span> <span class="dv">2</span>)
z[<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;d&quot;</span>)]
<span class="co">#&gt; &lt;NA&gt; &lt;NA&gt; </span>
<span class="co">#&gt;   NA   NA</span></code></pre></li>
</ul>
<h3>Lists</h3>
<p>Subsetting a list works in the same way as subsetting an atomic vector. Using <code>[</code> will always return a list; <code>[[</code> and <code>$</code>, as described below, let you pull out the components of the list.  </p>
<h3 id="matrix-subsetting">Matrices and arrays</h3>
<p>You can subset higher-dimensional structures in three ways:  </p>
<ul>
<li>With multiple vectors.</li>
<li>With a single vector.</li>
<li>With a matrix.</li>
</ul>
<p>The most common way of subsetting matrices (2d) and arrays (&gt;2d) is a simple generalisation of 1d subsetting: you supply a 1d index for each dimension, separated by a comma. Blank subsetting is now useful because it lets you keep all rows or all columns.</p>
<pre class="sourceCode r"><code class="sourceCode r">a &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span>:<span class="dv">9</span>, <span class="dt">nrow =</span> <span class="dv">3</span>)
<span class="kw">colnames</span>(a) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>, <span class="st">&quot;C&quot;</span>)
a[<span class="dv">1</span>:<span class="dv">2</span>, ]
<span class="co">#&gt;      A B C</span>
<span class="co">#&gt; [1,] 1 4 7</span>
<span class="co">#&gt; [2,] 2 5 8</span>
a[<span class="kw">c</span>(T, F, T), <span class="kw">c</span>(<span class="st">&quot;B&quot;</span>, <span class="st">&quot;A&quot;</span>)]
<span class="co">#&gt;      B A</span>
<span class="co">#&gt; [1,] 4 1</span>
<span class="co">#&gt; [2,] 6 3</span>
a[<span class="dv">0</span>, -<span class="dv">2</span>]
<span class="co">#&gt;      A C</span></code></pre>
<p>By default, <code>[</code> will simplify the results to the lowest possible dimensionality. See <a href="Subsetting.html#simplify-preserve">simplifying vs. preserving</a> to learn how to avoid this.</p>
<p>Because matrices and arrays are implemented as vectors with special attributes, you can subset them with a single vector. In that case, they will behave like a vector. Arrays in R are stored in column-major order:</p>
<pre class="sourceCode r"><code class="sourceCode r">(vals &lt;-<span class="st"> </span><span class="kw">outer</span>(<span class="dv">1</span>:<span class="dv">5</span>, <span class="dv">1</span>:<span class="dv">5</span>, <span class="dt">FUN =</span> <span class="st">&quot;paste&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;,&quot;</span>))
<span class="co">#&gt;      [,1]  [,2]  [,3]  [,4]  [,5] </span>
<span class="co">#&gt; [1,] &quot;1,1&quot; &quot;1,2&quot; &quot;1,3&quot; &quot;1,4&quot; &quot;1,5&quot;</span>
<span class="co">#&gt; [2,] &quot;2,1&quot; &quot;2,2&quot; &quot;2,3&quot; &quot;2,4&quot; &quot;2,5&quot;</span>
<span class="co">#&gt; [3,] &quot;3,1&quot; &quot;3,2&quot; &quot;3,3&quot; &quot;3,4&quot; &quot;3,5&quot;</span>
<span class="co">#&gt; [4,] &quot;4,1&quot; &quot;4,2&quot; &quot;4,3&quot; &quot;4,4&quot; &quot;4,5&quot;</span>
<span class="co">#&gt; [5,] &quot;5,1&quot; &quot;5,2&quot; &quot;5,3&quot; &quot;5,4&quot; &quot;5,5&quot;</span>
vals[<span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">15</span>)]
<span class="co">#&gt; [1] &quot;4,1&quot; &quot;5,3&quot;</span></code></pre>
<p>You can also subset higher-dimensional data structures with an integer matrix (or, if named, a character matrix). Each row in the matrix specifies the location of one value, where each column corresponds to a dimension in the array being subsetted. This means that you use a 2 column matrix to subset a matrix, a 3 column matrix to subset a 3d array, and so on. The result is a vector of values:</p>
<pre class="sourceCode r"><code class="sourceCode r">vals &lt;-<span class="st"> </span><span class="kw">outer</span>(<span class="dv">1</span>:<span class="dv">5</span>, <span class="dv">1</span>:<span class="dv">5</span>, <span class="dt">FUN =</span> <span class="st">&quot;paste&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;,&quot;</span>)
select &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dt">ncol =</span> <span class="dv">2</span>, <span class="dt">byrow =</span> <span class="ot">TRUE</span>, <span class="kw">c</span>(
  <span class="dv">1</span>, <span class="dv">1</span>,
  <span class="dv">3</span>, <span class="dv">1</span>,
  <span class="dv">2</span>, <span class="dv">4</span>
))
vals[select]
<span class="co">#&gt; [1] &quot;1,1&quot; &quot;3,1&quot; &quot;2,4&quot;</span></code></pre>
<h3 id="df-subsetting">Data frames</h3>
<p>Data frames possess the characteristics of both lists and matrices: if you subset with a single vector, they behave like lists; if you subset with two vectors, they behave like matrices.  </p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span>:<span class="dv">3</span>, <span class="dt">y =</span> <span class="dv">3</span>:<span class="dv">1</span>, <span class="dt">z =</span> letters[<span class="dv">1</span>:<span class="dv">3</span>])

df[df$x ==<span class="st"> </span><span class="dv">2</span>, ]
<span class="co">#&gt;   x y z</span>
<span class="co">#&gt; 2 2 2 b</span>
df[<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>), ]
<span class="co">#&gt;   x y z</span>
<span class="co">#&gt; 1 1 3 a</span>
<span class="co">#&gt; 3 3 1 c</span>

<span class="co"># There are two ways to select columns from a data frame</span>
<span class="co"># Like a list:</span>
df[<span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;z&quot;</span>)]
<span class="co">#&gt;   x z</span>
<span class="co">#&gt; 1 1 a</span>
<span class="co">#&gt; 2 2 b</span>
<span class="co">#&gt; 3 3 c</span>
<span class="co"># Like a matrix</span>
df[, <span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;z&quot;</span>)]
<span class="co">#&gt;   x z</span>
<span class="co">#&gt; 1 1 a</span>
<span class="co">#&gt; 2 2 b</span>
<span class="co">#&gt; 3 3 c</span>

<span class="co"># There&#39;s an important difference if you select a single </span>
<span class="co"># column: matrix subsetting simplifies by default, list </span>
<span class="co"># subsetting does not.</span>
<span class="kw">str</span>(df[<span class="st">&quot;x&quot;</span>])
<span class="co">#&gt; &#39;data.frame&#39;:    3 obs. of  1 variable:</span>
<span class="co">#&gt;  $ x: int  1 2 3</span>
<span class="kw">str</span>(df[, <span class="st">&quot;x&quot;</span>])
<span class="co">#&gt;  int [1:3] 1 2 3</span></code></pre>
<h3>S3 objects</h3>
<p>S3 objects are made up of atomic vectors, arrays, and lists, so you can always pull apart an S3 object using the techniques described above and the knowledge you gain from <code>str()</code>.  </p>
<h3>S4 objects</h3>
<p>There are also two additional subsetting operators that are needed for S4 objects: <code>@</code> (equivalent to <code>$</code>), and <code>slot()</code> (equivalent to <code>[[</code>). <code>@</code> is more restrictive than <code>$</code> in that it will return an error if the slot does not exist. These are described in more detail in <a href="OO-essentials.html#s4">the OO field guide</a>.   </p>
<h3>Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Fix each of the following common data frame subsetting errors:</p>
<pre class="sourceCode r"><code class="sourceCode r">mtcars[mtcars$cyl =<span class="st"> </span><span class="dv">4</span>, ]
mtcars[-<span class="dv">1</span>:<span class="dv">4</span>, ]
mtcars[mtcars$cyl &lt;=<span class="st"> </span><span class="dv">5</span>]
mtcars[mtcars$cyl ==<span class="st"> </span><span class="dv">4</span> |<span class="st"> </span><span class="dv">6</span>, ]</code></pre></li>
<li><p>Why does <code>x &lt;- 1:5; x[NA]</code> yield five missing values? (Hint: why is it different from <code>x[NA_real_]</code>?)</p></li>
<li><p>What does <code>upper.tri()</code> return? How does subsetting a matrix with it work? Do we need any additional subsetting rules to describe its behaviour?</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">outer</span>(<span class="dv">1</span>:<span class="dv">5</span>, <span class="dv">1</span>:<span class="dv">5</span>, <span class="dt">FUN =</span> <span class="st">&quot;*&quot;</span>)
x[<span class="kw">upper.tri</span>(x)]</code></pre></li>
<li><p>Why does <code>mtcars[1:20]</code> return a error? How does it differ from the similar <code>mtcars[1:20, ]</code>?</p></li>
<li><p>Implement your own function that extracts the diagonal entries from a matrix (it should behave like <code>diag(x)</code> where <code>x</code> is a matrix).</p></li>
<li><p>What does <code>df[is.na(df)] &lt;- 0</code> do? How does it work?</p></li>
</ol>
<h2 id="subsetting-operators">Subsetting operators</h2>
<p>There are two other subsetting operators: <code>[[</code> and <code>$</code>. <code>[[</code> is similar to <code>[</code>, except it can only return a single value and it allows you to pull pieces out of a list. <code>$</code> is a useful shorthand for <code>[[</code> combined with character subsetting.  </p>
<p>You need <code>[[</code> when working with lists. This is because when <code>[</code> is applied to a list it always returns a list: it never gives you the contents of the list. To get the contents, you need <code>[[</code>:</p>
<blockquote>
<p>“If list <code>x</code> is a train carrying objects, then <code>x[[5]]</code> is the object in car 5; <code>x[4:6]</code> is a train of cars 4-6.”</p>
<p>— <span class="citation">@RLangTip</span></p>
</blockquote>
<p>Because it can return only a single value, you must use <code>[[</code> with either a single positive integer or a string:  </p>
<pre class="sourceCode r"><code class="sourceCode r">a &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">a =</span> <span class="dv">1</span>, <span class="dt">b =</span> <span class="dv">2</span>)
a[[<span class="dv">1</span>]]
<span class="co">#&gt; [1] 1</span>
a[[<span class="st">&quot;a&quot;</span>]]
<span class="co">#&gt; [1] 1</span>

<span class="co"># If you do supply a vector it indexes recursively</span>
b &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">a =</span> <span class="kw">list</span>(<span class="dt">b =</span> <span class="kw">list</span>(<span class="dt">c =</span> <span class="kw">list</span>(<span class="dt">d =</span> <span class="dv">1</span>))))
b[[<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>, <span class="st">&quot;d&quot;</span>)]]
<span class="co">#&gt; [1] 1</span>
<span class="co"># Same as</span>
b[[<span class="st">&quot;a&quot;</span>]][[<span class="st">&quot;b&quot;</span>]][[<span class="st">&quot;c&quot;</span>]][[<span class="st">&quot;d&quot;</span>]]
<span class="co">#&gt; [1] 1</span></code></pre>
<p>Because data frames are lists of columns, you can use <code>[[</code> to extract a column from data frames: <code>mtcars[[1]]</code>, <code>mtcars[[&quot;cyl&quot;]]</code>.  </p>
<p>S3 and S4 objects can override the standard behaviour of <code>[</code> and <code>[[</code> so they behave differently for different types of objects. The key difference is usually how you select between simplifying or preserving behaviours, and what the default is.</p>
<h3 id="simplify-preserve">Simplifying vs. preserving subsetting</h3>
<p>It’s important to understand the distinction between simplifying and preserving subsetting. Simplifying subsets returns the simplest possible data structure that can represent the output, and is useful interactively because it usually gives you what you want. Preserving subsetting keeps the structure of the output the same as the input, and is generally better for programming because the result will always be the same type. Omitting <code>drop = FALSE</code> when subsetting matrices and data frames is one of the most common sources of programming errors. (It will work for your test cases, but then someone will pass in a single column data frame and it will fail in an unexpected and unclear way.)   </p>
<p>Unfortunately, how you switch between simplifying and preserving differs for different data types, as summarised in the table below.</p>
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="left">Simplifying</th>
<th align="left">Preserving</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Vector</td>
<td align="left"><code>x[[1]]</code></td>
<td align="left"><code>x[1]</code></td>
</tr>
<tr class="even">
<td align="left">List</td>
<td align="left"><code>x[[1]]</code></td>
<td align="left"><code>x[1]</code></td>
</tr>
<tr class="odd">
<td align="left">Factor</td>
<td align="left"><code>x[1:4, drop = T]</code></td>
<td align="left"><code>x[1:4]</code></td>
</tr>
<tr class="even">
<td align="left">Array</td>
<td align="left"><code>x[1, ]</code> <strong>or</strong> <code>x[, 1]</code></td>
<td align="left"><code>x[1, , drop = F]</code> <strong>or</strong> <code>x[, 1, drop = F]</code></td>
</tr>
<tr class="odd">
<td align="left">Data frame</td>
<td align="left"><code>x[, 1]</code> <strong>or</strong> <code>x[[1]]</code></td>
<td align="left"><code>x[, 1, drop = F]</code> <strong>or</strong> <code>x[1]</code></td>
</tr>
</tbody>
</table>
<p>Preserving is the same for all data types: you get the same type of output as input. Simplifying behaviour varies slightly between different data types, as described below:</p>
<ul>
<li><p><strong>Atomic vector</strong>: removes names.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dt">a =</span> <span class="dv">1</span>, <span class="dt">b =</span> <span class="dv">2</span>)
x[<span class="dv">1</span>]
<span class="co">#&gt; a </span>
<span class="co">#&gt; 1</span>
x[[<span class="dv">1</span>]]
<span class="co">#&gt; [1] 1</span></code></pre></li>
<li><p><strong>List</strong>: return the object inside the list, not a single element list.</p>
<pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">a =</span> <span class="dv">1</span>, <span class="dt">b =</span> <span class="dv">2</span>)
<span class="kw">str</span>(y[<span class="dv">1</span>])
<span class="co">#&gt; List of 1</span>
<span class="co">#&gt;  $ a: num 1</span>
<span class="kw">str</span>(y[[<span class="dv">1</span>]])
<span class="co">#&gt;  num 1</span></code></pre></li>
<li><p><strong>Factor</strong>: drops any unused levels.</p>
<pre class="sourceCode r"><code class="sourceCode r">z &lt;-<span class="st"> </span><span class="kw">factor</span>(<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>))
z[<span class="dv">1</span>]
<span class="co">#&gt; [1] a</span>
<span class="co">#&gt; Levels: a b</span>
z[<span class="dv">1</span>, drop =<span class="st"> </span><span class="ot">TRUE</span>]
<span class="co">#&gt; [1] a</span>
<span class="co">#&gt; Levels: a</span></code></pre></li>
<li><p><strong>Matrix</strong> or <strong>array</strong>: if any of the dimensions has length 1, drops that dimension.</p>
<pre class="sourceCode r"><code class="sourceCode r">a &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span>:<span class="dv">4</span>, <span class="dt">nrow =</span> <span class="dv">2</span>)
a[<span class="dv">1</span>, , drop =<span class="st"> </span><span class="ot">FALSE</span>]
<span class="co">#&gt;      [,1] [,2]</span>
<span class="co">#&gt; [1,]    1    3</span>
a[<span class="dv">1</span>, ]
<span class="co">#&gt; [1] 1 3</span></code></pre></li>
<li><p><strong>Data frame</strong>: if output is a single column, returns a vector instead of a data frame.</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">a =</span> <span class="dv">1</span>:<span class="dv">2</span>, <span class="dt">b =</span> <span class="dv">1</span>:<span class="dv">2</span>)
<span class="kw">str</span>(df[<span class="dv">1</span>])
<span class="co">#&gt; &#39;data.frame&#39;:    2 obs. of  1 variable:</span>
<span class="co">#&gt;  $ a: int  1 2</span>
<span class="kw">str</span>(df[[<span class="dv">1</span>]])
<span class="co">#&gt;  int [1:2] 1 2</span>
<span class="kw">str</span>(df[, <span class="st">&quot;a&quot;</span>, <span class="dt">drop =</span> <span class="ot">FALSE</span>])
<span class="co">#&gt; &#39;data.frame&#39;:    2 obs. of  1 variable:</span>
<span class="co">#&gt;  $ a: int  1 2</span>
<span class="kw">str</span>(df[, <span class="st">&quot;a&quot;</span>])
<span class="co">#&gt;  int [1:2] 1 2</span></code></pre></li>
</ul>
<h3><code>$</code></h3>
<p><code>$</code> is a shorthand operator, where <code>x$y</code> is equivalent to <code>x[[&quot;y&quot;, exact = FALSE]]</code>. It’s often used to access variables in a data frame, as in <code>mtcars$cyl</code> or <code>diamonds$carat</code>.  </p>
<p>One common mistake with <code>$</code> is to try and use it when you have the name of a column stored in a variable:</p>
<pre class="sourceCode r"><code class="sourceCode r">var &lt;-<span class="st"> &quot;cyl&quot;</span>
<span class="co"># Doesn&#39;t work - mtcars$var translated to mtcars[[&quot;var&quot;]]</span>
mtcars$var
<span class="co">#&gt; NULL</span>

<span class="co"># Instead use [[</span>
mtcars[[var]]
<span class="co">#&gt;  [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4</span></code></pre>
<p>There’s one important difference between <code>$</code> and <code>[[</code>. <code>$</code> does partial matching:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">abc =</span> <span class="dv">1</span>)
x$a
<span class="co">#&gt; [1] 1</span>
x[[<span class="st">&quot;a&quot;</span>]]
<span class="co">#&gt; NULL</span></code></pre>
<p>If you want to avoid this behaviour you can set the global option <code>warnPartialMatchDollar</code> to <code>TRUE</code>. Use with caution: it may affect behaviour in other code you have loaded (e.g., from a package).</p>
<h3>Missing/out of bounds indices</h3>
<p><code>[</code> and <code>[[</code> differ slightly in their behaviour when the index is out of bounds (OOB), for example, when you try to extract the fifth element of a length four vector, or subset a vector with <code>NA</code> or <code>NULL</code>:  </p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">1</span>:<span class="dv">4</span>
<span class="kw">str</span>(x[<span class="dv">5</span>])
<span class="co">#&gt;  int NA</span>
<span class="kw">str</span>(x[<span class="ot">NA_real_</span>])
<span class="co">#&gt;  int NA</span>
<span class="kw">str</span>(x[<span class="ot">NULL</span>])
<span class="co">#&gt;  int(0)</span></code></pre>
<p>The following table summarises the results of subsetting atomic vectors and lists with <code>[</code> and <code>[[</code> and different types of OOB value.</p>
<table>
<thead>
<tr class="header">
<th align="left">Operator</th>
<th align="left">Index</th>
<th align="left">Atomic</th>
<th align="left">List</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>[</code></td>
<td align="left">OOB</td>
<td align="left"><code>NA</code></td>
<td align="left"><code>list(NULL)</code></td>
</tr>
<tr class="even">
<td align="left"><code>[</code></td>
<td align="left"><code>NA_real_</code></td>
<td align="left"><code>NA</code></td>
<td align="left"><code>list(NULL)</code></td>
</tr>
<tr class="odd">
<td align="left"><code>[</code></td>
<td align="left"><code>NULL</code></td>
<td align="left"><code>x[0]</code></td>
<td align="left"><code>list(NULL)</code></td>
</tr>
<tr class="even">
<td align="left"><code>[[</code></td>
<td align="left">OOB</td>
<td align="left">Error</td>
<td align="left">Error</td>
</tr>
<tr class="odd">
<td align="left"><code>[[</code></td>
<td align="left"><code>NA_real_</code></td>
<td align="left">Error</td>
<td align="left"><code>NULL</code></td>
</tr>
<tr class="even">
<td align="left"><code>[[</code></td>
<td align="left"><code>NULL</code></td>
<td align="left">Error</td>
<td align="left">Error</td>
</tr>
</tbody>
</table>
<p>If the input vector is named, then the names of OOB, missing, or <code>NULL</code> components will be <code>&quot;&lt;NA&gt;&quot;</code>.</p>
<h3>Exercises</h3>
<ol style="list-style-type: decimal">
<li>Given a linear model, e.g., <code>mod &lt;- lm(mpg ~ wt, data = mtcars)</code>, extract the residual degrees of freedom. Extract the R squared from the model summary (<code>summary(mod)</code>)</li>
</ol>
<!-- FIXME: more examples -->

<h2 id="subassignment">Subsetting and assignment</h2>
<p>All subsetting operators can be combined with assignment to modify selected values of the input vector.  </p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">1</span>:<span class="dv">5</span>
x[<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>)] &lt;-<span class="st"> </span><span class="dv">2</span>:<span class="dv">3</span>
x
<span class="co">#&gt; [1] 2 3 3 4 5</span>

<span class="co"># The length of the LHS needs to match the RHS</span>
x[-<span class="dv">1</span>] &lt;-<span class="st"> </span><span class="dv">4</span>:<span class="dv">1</span>
x
<span class="co">#&gt; [1] 2 4 3 2 1</span>

<span class="co"># Note that there&#39;s no checking for duplicate indices</span>
x[<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>)] &lt;-<span class="st"> </span><span class="dv">2</span>:<span class="dv">3</span>
x
<span class="co">#&gt; [1] 3 4 3 2 1</span>

<span class="co"># You can&#39;t combine integer indices with NA</span>
x[<span class="kw">c</span>(<span class="dv">1</span>, <span class="ot">NA</span>)] &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>)
<span class="co">#&gt; Error in x[c(1, NA)] &lt;- c(1, 2): NAs are not allowed in subscripted assignments</span>
<span class="co"># But you can combine logical indices with NA</span>
<span class="co"># (where they&#39;re treated as false).</span>
x[<span class="kw">c</span>(T, F, <span class="ot">NA</span>)] &lt;-<span class="st"> </span><span class="dv">1</span>
x
<span class="co">#&gt; [1] 1 4 3 1 1</span>

<span class="co"># This is mostly useful when conditionally modifying vectors</span>
df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">a =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">10</span>, <span class="ot">NA</span>))
df$a[df$a &lt;<span class="st"> </span><span class="dv">5</span>] &lt;-<span class="st"> </span><span class="dv">0</span>
df$a
<span class="co">#&gt; [1]  0 10 NA</span></code></pre>
<p>Subsetting with nothing can be useful in conjunction with assignment because it will preserve the original object class and structure. Compare the following two expressions. In the first, <code>mtcars</code> will remain as a data frame. In the second, <code>mtcars</code> will become a list.</p>
<pre class="sourceCode r"><code class="sourceCode r">mtcars[] &lt;-<span class="st"> </span><span class="kw">lapply</span>(mtcars, as.integer)
mtcars &lt;-<span class="st"> </span><span class="kw">lapply</span>(mtcars, as.integer)</code></pre>
<p>With lists, you can use subsetting + assignment + <code>NULL</code> to remove components from a list. To add a literal <code>NULL</code> to a list, use <code>[</code> and <code>list(NULL)</code>: </p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">a =</span> <span class="dv">1</span>, <span class="dt">b =</span> <span class="dv">2</span>)
x[[<span class="st">&quot;b&quot;</span>]] &lt;-<span class="st"> </span><span class="ot">NULL</span>
<span class="kw">str</span>(x)
<span class="co">#&gt; List of 1</span>
<span class="co">#&gt;  $ a: num 1</span>

y &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">a =</span> <span class="dv">1</span>)
y[<span class="st">&quot;b&quot;</span>] &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="ot">NULL</span>)
<span class="kw">str</span>(y)
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ a: num 1</span>
<span class="co">#&gt;  $ b: NULL</span></code></pre>
<h2 id="applications">Applications</h2>
<p>The basic principles described above give rise to a wide variety of useful applications. Some of the most important are described below. Many of these basic techniques are wrapped up into more concise functions (e.g., <code>subset()</code>, <code>merge()</code>, <code>plyr::arrange()</code>), but it is useful to understand how they are implemented with basic subsetting. This will allow you to adapt to new situations that are not dealt with by existing functions.</p>
<h3 id="lookup-tables">Lookup tables (character subsetting)</h3>
<p>Character matching provides a powerful way to make lookup tables. Say you want to convert abbreviations: </p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;m&quot;</span>, <span class="st">&quot;f&quot;</span>, <span class="st">&quot;u&quot;</span>, <span class="st">&quot;f&quot;</span>, <span class="st">&quot;f&quot;</span>, <span class="st">&quot;m&quot;</span>, <span class="st">&quot;m&quot;</span>)
lookup &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dt">m =</span> <span class="st">&quot;Male&quot;</span>, <span class="dt">f =</span> <span class="st">&quot;Female&quot;</span>, <span class="dt">u =</span> <span class="ot">NA</span>)
lookup[x]
<span class="co">#&gt;        m        f        u        f        f        m        m </span>
<span class="co">#&gt;   &quot;Male&quot; &quot;Female&quot;       NA &quot;Female&quot; &quot;Female&quot;   &quot;Male&quot;   &quot;Male&quot;</span>
<span class="kw">unname</span>(lookup[x])
<span class="co">#&gt; [1] &quot;Male&quot;   &quot;Female&quot; NA       &quot;Female&quot; &quot;Female&quot; &quot;Male&quot;   &quot;Male&quot;</span>

<span class="co"># Or with fewer output values</span>
<span class="kw">c</span>(<span class="dt">m =</span> <span class="st">&quot;Known&quot;</span>, <span class="dt">f =</span> <span class="st">&quot;Known&quot;</span>, <span class="dt">u =</span> <span class="st">&quot;Unknown&quot;</span>)[x]
<span class="co">#&gt;         m         f         u         f         f         m         m </span>
<span class="co">#&gt;   &quot;Known&quot;   &quot;Known&quot; &quot;Unknown&quot;   &quot;Known&quot;   &quot;Known&quot;   &quot;Known&quot;   &quot;Known&quot;</span></code></pre>
<p>If you don’t want names in the result, use <code>unname()</code> to remove them.</p>
<h3 id="matching-merging">Matching and merging by hand (integer subsetting)</h3>
<p>You may have a more complicated lookup table which has multiple columns of information. Suppose we have a vector of integer grades, and a table that describes their properties: </p>
<pre class="sourceCode r"><code class="sourceCode r">grades &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">1</span>)

info &lt;-<span class="st"> </span><span class="kw">data.frame</span>(
  <span class="dt">grade =</span> <span class="dv">3</span>:<span class="dv">1</span>,
  <span class="dt">desc =</span> <span class="kw">c</span>(<span class="st">&quot;Excellent&quot;</span>, <span class="st">&quot;Good&quot;</span>, <span class="st">&quot;Poor&quot;</span>),
  <span class="dt">fail =</span> <span class="kw">c</span>(F, F, T)
)</code></pre>
<p>We want to duplicate the info table so that we have a row for each value in <code>grades</code>. We can do this in two ways, either using <code>match()</code> and integer subsetting, or <code>rownames()</code> and character subsetting: </p>
<pre class="sourceCode r"><code class="sourceCode r">grades
<span class="co">#&gt; [1] 1 2 2 3 1</span>

<span class="co"># Using match</span>
id &lt;-<span class="st"> </span><span class="kw">match</span>(grades, info$grade)
info[id, ]
<span class="co">#&gt;     grade      desc  fail</span>
<span class="co">#&gt; 3       1      Poor  TRUE</span>
<span class="co">#&gt; 2       2      Good FALSE</span>
<span class="co">#&gt; 2.1     2      Good FALSE</span>
<span class="co">#&gt; 1       3 Excellent FALSE</span>
<span class="co">#&gt; 3.1     1      Poor  TRUE</span>

<span class="co"># Using rownames</span>
<span class="kw">rownames</span>(info) &lt;-<span class="st"> </span>info$grade
info[<span class="kw">as.character</span>(grades), ]
<span class="co">#&gt;     grade      desc  fail</span>
<span class="co">#&gt; 1       1      Poor  TRUE</span>
<span class="co">#&gt; 2       2      Good FALSE</span>
<span class="co">#&gt; 2.1     2      Good FALSE</span>
<span class="co">#&gt; 3       3 Excellent FALSE</span>
<span class="co">#&gt; 1.1     1      Poor  TRUE</span></code></pre>
<p>If you have multiple columns to match on, you’ll need to first collapse them to a single column (with <code>interaction()</code>, <code>paste()</code>, or <code>plyr::id()</code>). You can also use <code>merge()</code> or <code>plyr::join()</code>, which do the same thing for you — read the source code to see how. </p>
<h3>Random samples/bootstrap (integer subsetting)</h3>
<p>You can use integer indices to perform random sampling or bootstrapping of a vector or data frame. <code>sample()</code> generates a vector of indices, then subsetting to access the values:    </p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">3</span>, <span class="dt">each =</span> <span class="dv">2</span>), <span class="dt">y =</span> <span class="dv">6</span>:<span class="dv">1</span>, <span class="dt">z =</span> letters[<span class="dv">1</span>:<span class="dv">6</span>])

<span class="co"># Set seed for reproducibility</span>
<span class="kw">set.seed</span>(<span class="dv">10</span>)

<span class="co"># Randomly reorder</span>
df[<span class="kw">sample</span>(<span class="kw">nrow</span>(df)), ]
<span class="co">#&gt;   x y z</span>
<span class="co">#&gt; 4 2 3 d</span>
<span class="co">#&gt; 2 1 5 b</span>
<span class="co">#&gt; 5 3 2 e</span>
<span class="co">#&gt; 3 2 4 c</span>
<span class="co">#&gt; 1 1 6 a</span>
<span class="co">#&gt; 6 3 1 f</span>
<span class="co"># Select 3 random rows</span>
df[<span class="kw">sample</span>(<span class="kw">nrow</span>(df), <span class="dv">3</span>), ]
<span class="co">#&gt;   x y z</span>
<span class="co">#&gt; 2 1 5 b</span>
<span class="co">#&gt; 6 3 1 f</span>
<span class="co">#&gt; 3 2 4 c</span>
<span class="co"># Select 6 bootstrap replicates</span>
df[<span class="kw">sample</span>(<span class="kw">nrow</span>(df), <span class="dv">6</span>, <span class="dt">rep =</span> T), ]
<span class="co">#&gt;     x y z</span>
<span class="co">#&gt; 3   2 4 c</span>
<span class="co">#&gt; 4   2 3 d</span>
<span class="co">#&gt; 4.1 2 3 d</span>
<span class="co">#&gt; 1   1 6 a</span>
<span class="co">#&gt; 4.2 2 3 d</span>
<span class="co">#&gt; 3.1 2 4 c</span></code></pre>
<p>The arguments of <code>sample()</code> control the number of samples to extract, and whether sampling is performed with or without replacement.</p>
<h3>Ordering (integer subsetting)</h3>
<p><code>order()</code> takes a vector as input and returns an integer vector describing how the subsetted vector should be ordered:  </p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>, <span class="st">&quot;a&quot;</span>)
<span class="kw">order</span>(x)
<span class="co">#&gt; [1] 3 1 2</span>
x[<span class="kw">order</span>(x)]
<span class="co">#&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot;</span></code></pre>
<p>To break ties, you can supply additional variables to <code>order()</code>, and you can change from ascending to descending order using <code>decreasing = TRUE</code>. By default, any missing values will be put at the end of the vector; however, you can remove them with <code>na.last = NA</code> or put at the front with <code>na.last = FALSE</code>.</p>
<p>For two or more dimensions, <code>order()</code> and integer subsetting makes it easy to order either the rows or columns of an object:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Randomly reorder df</span>
df2 &lt;-<span class="st"> </span>df[<span class="kw">sample</span>(<span class="kw">nrow</span>(df)), <span class="dv">3</span>:<span class="dv">1</span>]
df2
<span class="co">#&gt;   z y x</span>
<span class="co">#&gt; 3 c 4 2</span>
<span class="co">#&gt; 1 a 6 1</span>
<span class="co">#&gt; 2 b 5 1</span>
<span class="co">#&gt; 4 d 3 2</span>
<span class="co">#&gt; 6 f 1 3</span>
<span class="co">#&gt; 5 e 2 3</span>

df2[<span class="kw">order</span>(df2$x), ]
<span class="co">#&gt;   z y x</span>
<span class="co">#&gt; 1 a 6 1</span>
<span class="co">#&gt; 2 b 5 1</span>
<span class="co">#&gt; 3 c 4 2</span>
<span class="co">#&gt; 4 d 3 2</span>
<span class="co">#&gt; 6 f 1 3</span>
<span class="co">#&gt; 5 e 2 3</span>
df2[, <span class="kw">order</span>(<span class="kw">names</span>(df2))]
<span class="co">#&gt;   x y z</span>
<span class="co">#&gt; 3 2 4 c</span>
<span class="co">#&gt; 1 1 6 a</span>
<span class="co">#&gt; 2 1 5 b</span>
<span class="co">#&gt; 4 2 3 d</span>
<span class="co">#&gt; 6 3 1 f</span>
<span class="co">#&gt; 5 3 2 e</span></code></pre>
<p>More concise, but less flexible, functions are available for sorting vectors, <code>sort()</code>, and data frames, <code>plyr::arrange()</code>. </p>
<h3>Expanding aggregated counts (integer subsetting)</h3>
<p>Sometimes you get a data frame where identical rows have been collapsed into one and a count column has been added. <code>rep()</code> and integer subsetting make it easy to uncollapse the data by subsetting with a repeated row index:</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">1</span>), <span class="dt">y =</span> <span class="kw">c</span>(<span class="dv">9</span>, <span class="dv">11</span>, <span class="dv">6</span>), <span class="dt">n =</span> <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">1</span>))
<span class="kw">rep</span>(<span class="dv">1</span>:<span class="kw">nrow</span>(df), df$n)
<span class="co">#&gt; [1] 1 1 1 2 2 2 2 2 3</span>
df[<span class="kw">rep</span>(<span class="dv">1</span>:<span class="kw">nrow</span>(df), df$n), ]
<span class="co">#&gt;     x  y n</span>
<span class="co">#&gt; 1   2  9 3</span>
<span class="co">#&gt; 1.1 2  9 3</span>
<span class="co">#&gt; 1.2 2  9 3</span>
<span class="co">#&gt; 2   4 11 5</span>
<span class="co">#&gt; 2.1 4 11 5</span>
<span class="co">#&gt; 2.2 4 11 5</span>
<span class="co">#&gt; 2.3 4 11 5</span>
<span class="co">#&gt; 2.4 4 11 5</span>
<span class="co">#&gt; 3   1  6 1</span></code></pre>
<h3>Removing columns from data frames (character subsetting)</h3>
<p>There are two ways to remove columns from a data frame. You can set individual columns to NULL: </p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span>:<span class="dv">3</span>, <span class="dt">y =</span> <span class="dv">3</span>:<span class="dv">1</span>, <span class="dt">z =</span> letters[<span class="dv">1</span>:<span class="dv">3</span>])
df$z &lt;-<span class="st"> </span><span class="ot">NULL</span></code></pre>
<p>Or you can subset to return only the columns you want:</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span>:<span class="dv">3</span>, <span class="dt">y =</span> <span class="dv">3</span>:<span class="dv">1</span>, <span class="dt">z =</span> letters[<span class="dv">1</span>:<span class="dv">3</span>])
df[<span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>)]
<span class="co">#&gt;   x y</span>
<span class="co">#&gt; 1 1 3</span>
<span class="co">#&gt; 2 2 2</span>
<span class="co">#&gt; 3 3 1</span></code></pre>
<p>If you know the columns you don’t want, use set operations to work out which colums to keep:</p>
<pre class="sourceCode r"><code class="sourceCode r">df[<span class="kw">setdiff</span>(<span class="kw">names</span>(df), <span class="st">&quot;z&quot;</span>)]
<span class="co">#&gt;   x y</span>
<span class="co">#&gt; 1 1 3</span>
<span class="co">#&gt; 2 2 2</span>
<span class="co">#&gt; 3 3 1</span></code></pre>
<h3>Selecting rows based on a condition (logical subsetting)</h3>
<p>Because it allows you to easily combine conditions from multiple columns, logical subsetting is probably the most commonly used technique for extracting rows out of a data frame. </p>
<pre class="sourceCode r"><code class="sourceCode r">mtcars[mtcars$gear ==<span class="st"> </span><span class="dv">5</span>, ]
<span class="co">#&gt;     mpg cyl  disp  hp drat    wt qsec vs am gear carb</span>
<span class="co">#&gt; 27 26.0   4 120.3  91 4.43 2.140 16.7  0  1    5    2</span>
<span class="co">#&gt; 28 30.4   4  95.1 113 3.77 1.513 16.9  1  1    5    2</span>
<span class="co">#&gt; 29 15.8   8 351.0 264 4.22 3.170 14.5  0  1    5    4</span>
<span class="co">#&gt; 30 19.7   6 145.0 175 3.62 2.770 15.5  0  1    5    6</span>
<span class="co">#&gt; 31 15.0   8 301.0 335 3.54 3.570 14.6  0  1    5    8</span>
mtcars[mtcars$gear ==<span class="st"> </span><span class="dv">5</span> &amp;<span class="st"> </span>mtcars$cyl ==<span class="st"> </span><span class="dv">4</span>, ]
<span class="co">#&gt;     mpg cyl  disp  hp drat    wt qsec vs am gear carb</span>
<span class="co">#&gt; 27 26.0   4 120.3  91 4.43 2.140 16.7  0  1    5    2</span>
<span class="co">#&gt; 28 30.4   4  95.1 113 3.77 1.513 16.9  1  1    5    2</span></code></pre>
<p>Remember to use the vector boolean operators <code>&amp;</code> and <code>|</code>, not the short-circuiting scalar operators <code>&amp;&amp;</code> and <code>||</code> which are more useful inside if statements. Don’t forget <a href="http://en.wikipedia.org/wiki/De_Morgan&#39;s_laws">De Morgan’s laws</a>, which can be useful to simplify negations:</p>
<ul>
<li><code>!(X &amp; Y)</code> is the same as <code>!X | !Y</code></li>
<li><code>!(X | Y)</code> is the same as <code>!X &amp; !Y</code></li>
</ul>
<p>For example, <code>!(X &amp; !(Y | Z))</code> simplifies to <code>!X | !!(Y|Z)</code>, and then to <code>!X | Y | Z</code>.</p>
<p><code>subset()</code> is a specialised shorthand function for subsetting data frames, and saves some typing because you don’t need to repeat the name of the data frame. You’ll learn how it works in <a href="Computing-on-the-language.html#nse">non-standard evaluation</a>. </p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">subset</span>(mtcars, gear ==<span class="st"> </span><span class="dv">5</span>)
<span class="co">#&gt;     mpg cyl  disp  hp drat    wt qsec vs am gear carb</span>
<span class="co">#&gt; 27 26.0   4 120.3  91 4.43 2.140 16.7  0  1    5    2</span>
<span class="co">#&gt; 28 30.4   4  95.1 113 3.77 1.513 16.9  1  1    5    2</span>
<span class="co">#&gt; 29 15.8   8 351.0 264 4.22 3.170 14.5  0  1    5    4</span>
<span class="co">#&gt; 30 19.7   6 145.0 175 3.62 2.770 15.5  0  1    5    6</span>
<span class="co">#&gt; 31 15.0   8 301.0 335 3.54 3.570 14.6  0  1    5    8</span>
<span class="kw">subset</span>(mtcars, gear ==<span class="st"> </span><span class="dv">5</span> &amp;<span class="st"> </span>cyl ==<span class="st"> </span><span class="dv">4</span>)
<span class="co">#&gt;     mpg cyl  disp  hp drat    wt qsec vs am gear carb</span>
<span class="co">#&gt; 27 26.0   4 120.3  91 4.43 2.140 16.7  0  1    5    2</span>
<span class="co">#&gt; 28 30.4   4  95.1 113 3.77 1.513 16.9  1  1    5    2</span></code></pre>
<h3>Boolean algebra vs. sets (logical &amp; integer subsetting)</h3>
<p>It’s useful to be aware of the natural equivalence between set operations (integer subsetting) and boolean algebra (logical subsetting). Using set operations is more effective when:  </p>
<ul>
<li><p>You want to find the first (or last) <code>TRUE</code>.</p></li>
<li><p>You have very few <code>TRUE</code>s and very many <code>FALSE</code>s; a set representation may be faster and require less storage.</p></li>
</ul>
<p><code>which()</code> allows you to convert a boolean representation to an integer representation. There’s no reverse operation in base R but we can easily create one: </p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">10</span>) &lt;<span class="st"> </span><span class="dv">4</span>
<span class="kw">which</span>(x)
<span class="co">#&gt; [1]  3  7 10</span>

unwhich &lt;-<span class="st"> </span>function(x, n) {
  out &lt;-<span class="st"> </span><span class="kw">rep_len</span>(<span class="ot">FALSE</span>, n)
  out[x] &lt;-<span class="st"> </span><span class="ot">TRUE</span>
  out
}
<span class="kw">unwhich</span>(<span class="kw">which</span>(x), <span class="dv">10</span>)
<span class="co">#&gt;  [1] FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE</span></code></pre>
<p>Let’s create two logical vectors and their integer equivalents and then explore the relationship between boolean and set operations.</p>
<pre class="sourceCode r"><code class="sourceCode r">(x1 &lt;-<span class="st"> </span><span class="dv">1</span>:<span class="dv">10</span> %%<span class="st"> </span><span class="dv">2</span> ==<span class="st"> </span><span class="dv">0</span>)
<span class="co">#&gt;  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE</span>
(x2 &lt;-<span class="st"> </span><span class="kw">which</span>(x1))
<span class="co">#&gt; [1]  2  4  6  8 10</span>
(y1 &lt;-<span class="st"> </span><span class="dv">1</span>:<span class="dv">10</span> %%<span class="st"> </span><span class="dv">5</span> ==<span class="st"> </span><span class="dv">0</span>)
<span class="co">#&gt;  [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE</span>
(y2 &lt;-<span class="st"> </span><span class="kw">which</span>(y1))
<span class="co">#&gt; [1]  5 10</span>

<span class="co"># X &amp; Y &lt;-&gt; intersect(x, y)</span>
x1 &amp;<span class="st"> </span>y1
<span class="co">#&gt;  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE</span>
<span class="kw">intersect</span>(x2, y2)
<span class="co">#&gt; [1] 10</span>

<span class="co"># X | Y &lt;-&gt; union(x, y)</span>
x1 |<span class="st"> </span>y1
<span class="co">#&gt;  [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE</span>
<span class="kw">union</span>(x2, y2)
<span class="co">#&gt; [1]  2  4  6  8 10  5</span>

<span class="co"># X &amp; !Y &lt;-&gt; setdiff(x, y)</span>
x1 &amp;<span class="st"> </span>!y1
<span class="co">#&gt;  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE</span>
<span class="kw">setdiff</span>(x2, y2)
<span class="co">#&gt; [1] 2 4 6 8</span>

<span class="co"># xor(X, Y) &lt;-&gt; setdiff(union(x, y), intersect(x, y))</span>
<span class="kw">xor</span>(x1, y1)
<span class="co">#&gt;  [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE</span>
<span class="kw">setdiff</span>(<span class="kw">union</span>(x2, y2), <span class="kw">intersect</span>(x2, y2))
<span class="co">#&gt; [1] 2 4 6 8 5</span></code></pre>
<p>When first learning subsetting, a common mistake is to use <code>x[which(y)]</code> instead of <code>x[y]</code>. Here the <code>which()</code> achieves nothing: it switches from logical to integer subsetting but the result will be exactly the same. Also beware that <code>x[-which(y)]</code> is <strong>not</strong> equivalent to <code>x[!y]</code>: if <code>y</code> is all FALSE, <code>which(y)</code> will be <code>integer(0)</code> and <code>-integer(0)</code> is still <code>integer(0)</code>, so you’ll get no values, instead of all values. In general, avoid switching from logical to integer subsetting unless you want, for example, the first or last <code>TRUE</code> value.</p>
<h3>Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>How would you randomly permute the columns of a data frame? (This is an important technique in random forests.) Can you simultaneously permute the rows and columns in one step?</p></li>
<li><p>How would you select a random sample of <code>m</code> rows from a data frame? What if the sample had to be contiguous (i.e., with an initial row, a final row, and every row in between)?</p></li>
<li><p>How could you put the columns in a data frame in alphabetical order?</p></li>
</ol>
<h2 id="subsetting-answers">Answers</h2>
<ol style="list-style-type: decimal">
<li><p>Positive integers select elements at specific positions, negative integers drop elements; logical vectors keep elements at positions corresponding to <code>TRUE</code>; character vectors select elements with matching names.</p></li>
<li><p><code>[</code> selects sub-lists. It always returns a list; if you use it with a single positive integer, it returns a list of length one. <code>[[</code> selects an element within a list. <code>$</code> is a convenient shorthand: <code>x$y</code> is equivalent to <code>x[[&quot;y&quot;]]</code>.</p></li>
<li><p>Use <code>drop = FALSE</code> if you are subsetting a matrix, array, or data frame and you want to preserve the original dimensions. You should almost always use it when subsetting inside a function.</p></li>
<li><p>If <code>x</code> is a matrix, <code>x[] &lt;- 0</code> will replace every element with 0, keeping the same number of rows and columns. <code>x &lt;- 0</code> completely replaces the matrix with the value 0.</p></li>
<li><p>A named character vector can act as a simple lookup table: <code>c(x = 1, y = 2, z = 3)[c(&quot;y&quot;, &quot;z&quot;, &quot;x&quot;)]</code></p></li>
</ol>

        </div>
      </div>

      <div class="footer">
        <hr>
        <p>&copy; Hadley Wickham. Powered by <a href="http://jekyllrb.com/">jekyll</a>,
          <a href="http://yihui.name/knitr/">knitr</a>, and
          <a href="http://johnmacfarlane.net/pandoc/">pandoc</a>. Source
          available on <a href="https://github.com/hadley/adv-r/">github</a>.
        </p>
      </div>

    </div> <!-- /container -->

  <script src="//code.jquery.com/jquery.js"></script>
  <script src="www/bootstrap.min.js"></script>
  <script src="www/toc.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-67989-16', 'had.co.nz');
    ga('send', 'pageview');

  </script>
  </body>
</html>
